From 8db5552d0a52cef86b5bfdb9de1929b584c086f9 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Sun, 29 Dec 2024 23:14:12 +0200
Subject: [PATCH 01/32] Reapply "Per desktop tiling"

This reverts commit 80aa37c5f2418923710ba5adcc4f3346459abe2d.
---
 autotests/integration/outputchanges_test.cpp |  25 +++-
 autotests/integration/tiles_test.cpp         |   6 +-
 src/scripting/tilemodel.cpp                  |  14 +-
 src/scripting/tilemodel.h                    |   5 +-
 src/tiles/customtile.cpp                     |  40 +++++-
 src/tiles/customtile.h                       |  10 +-
 src/tiles/quicktile.cpp                      |  27 +++-
 src/tiles/quicktile.h                        |   6 +-
 src/tiles/tile.cpp                           | 128 ++++++++++++++---
 src/tiles/tile.h                             |  15 +-
 src/tiles/tilemanager.cpp                    | 136 +++++++++++++++----
 src/tiles/tilemanager.h                      |  22 ++-
 src/window.cpp                               |  43 ++++--
 src/window.h                                 |   3 +-
 src/workspace.cpp                            |  10 +-
 15 files changed, 386 insertions(+), 104 deletions(-)

diff --git a/autotests/integration/outputchanges_test.cpp b/autotests/integration/outputchanges_test.cpp
index f7b2a196523..45362d29298 100644
--- a/autotests/integration/outputchanges_test.cpp
+++ b/autotests/integration/outputchanges_test.cpp
@@ -559,7 +559,7 @@ void OutputChangesTest::testQuickTiledWindowRestoredAfterEnablingOutput()
     // kwin will send a configure event with the actived state.
     QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
     QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
-    QSignalSpy quickTileChangedSpy(window, &Window::quickTileModeChanged);
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
     QVERIFY(surfaceConfigureRequestedSpy.wait());
 
     // Move the window to the right monitor and tile it to the right.
@@ -571,9 +571,10 @@ void OutputChangesTest::testQuickTiledWindowRestoredAfterEnablingOutput()
     shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
     Test::render(surface.get(), QSize(1280 / 2, 1024), Qt::blue);
     QVERIFY(frameGeometryChangedSpy.wait());
-    const QRectF rightQuickTileGeom = QRectF(1280 + 1280 / 2, 0, 1280 / 2, 1024);
-    QCOMPARE(window->frameGeometry(), rightQuickTileGeom);
-    QCOMPARE(window->moveResizeGeometry(), rightQuickTileGeom);
+    const QRectF rightQuickTileGeomScreen2 = QRectF(1280 + 1280 / 2, 0, 1280 / 2, 1024);
+    const QRectF rightQuickTileGeomScreen1 = QRectF(1280 / 2, 0, 1280 / 2, 1024);
+    QCOMPARE(window->frameGeometry(), rightQuickTileGeomScreen2);
+    QCOMPARE(window->moveResizeGeometry(), rightQuickTileGeomScreen2);
     QCOMPARE(window->output(), outputs[1]);
     QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
     QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
@@ -585,10 +586,20 @@ void OutputChangesTest::testQuickTiledWindowRestoredAfterEnablingOutput()
         auto changeSet = config1.changeSet(outputs[1]);
         changeSet->enabled = false;
     }
+
     workspace()->applyOutputConfiguration(config1);
 
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(toplevelConfigureRequestedSpy.last().at(0).value<QSize>(), QSize(1280 / 2, 1024));
+    shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+    Test::render(surface.get(), QSize(1280 / 2, 1024), Qt::blue);
+
     // The window will be moved to the left monitor
     QCOMPARE(window->output(), outputs[0]);
+    QVERIFY(tileChangedSpy.wait());
+    qWarning() << window->requestedTile()->windowGeometry();
+    QCOMPARE(window->frameGeometry(), rightQuickTileGeomScreen1);
+    QCOMPARE(window->moveResizeGeometry(), rightQuickTileGeomScreen1);
 
     // Enable the right monitor again
     OutputConfiguration config2;
@@ -600,11 +611,11 @@ void OutputChangesTest::testQuickTiledWindowRestoredAfterEnablingOutput()
     QVERIFY(surfaceConfigureRequestedSpy.wait());
     shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
     Test::render(surface.get(), QSize(1280 / 2, 1024), Qt::blue);
-    QVERIFY(quickTileChangedSpy.wait());
+    QVERIFY(tileChangedSpy.wait());
 
     // The window will be moved back to the right monitor, and put in the correct tile
-    QCOMPARE(window->frameGeometry(), rightQuickTileGeom);
-    QCOMPARE(window->moveResizeGeometry(), rightQuickTileGeom);
+    QCOMPARE(window->frameGeometry(), rightQuickTileGeomScreen2);
+    QCOMPARE(window->moveResizeGeometry(), rightQuickTileGeomScreen2);
     QCOMPARE(window->output(), outputs[1]);
     QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
     QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index 168858e2df2..71b9447f98e 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -153,7 +153,7 @@ void TilesTest::testWindowInteraction()
     auto leftTile = qobject_cast<CustomTile *>(m_rootTile->childTiles().first());
     QVERIFY(leftTile);
 
-    rootWindow->requestTile(leftTile);
+    leftTile->addWindow(rootWindow);
     QVERIFY(surfaceConfigureRequestedSpy.wait());
     QCOMPARE(surfaceConfigureRequestedSpy.count(), 2);
     QCOMPARE(toplevelConfigureRequestedSpy.count(), 2);
@@ -224,7 +224,7 @@ void TilesTest::testAssignedTileDeletion()
     auto middleBottomTile = qobject_cast<CustomTile *>(m_rootTile->childTiles()[1]->childTiles()[1]);
     QVERIFY(middleBottomTile);
 
-    rootWindow->requestTile(middleBottomTile);
+    middleBottomTile->addWindow(rootWindow);
     QVERIFY(surfaceConfigureRequestedSpy.wait());
     QCOMPARE(surfaceConfigureRequestedSpy.count(), 2);
     QCOMPARE(toplevelConfigureRequestedSpy.count(), 2);
@@ -301,7 +301,7 @@ void TilesTest::resizeTileFromWindow()
     QVERIFY(bottomLeftTile);
     QCOMPARE(bottomLeftTile->windowGeometry(), QRectF(4, 514, 506, 506));
 
-    window->requestTile(topLeftTile);
+    topLeftTile->addWindow(window);
     QVERIFY(surfaceConfigureRequestedSpy.wait());
     QCOMPARE(surfaceConfigureRequestedSpy.count(), 2);
     QCOMPARE(toplevelConfigureRequestedSpy.count(), 2);
diff --git a/src/scripting/tilemodel.cpp b/src/scripting/tilemodel.cpp
index ae78b2ad41b..0d511eb81fc 100644
--- a/src/scripting/tilemodel.cpp
+++ b/src/scripting/tilemodel.cpp
@@ -23,9 +23,9 @@
 namespace KWin
 {
 
-TileModel::TileModel(TileManager *parent)
+TileModel::TileModel(Tile *parent)
     : QAbstractItemModel(parent)
-    , m_tileManager(parent)
+    , m_rootTile(parent)
 {
 }
 
@@ -71,7 +71,7 @@ QModelIndex TileModel::index(int row, int column, const QModelIndex &parent) con
     CustomTile *parentItem;
 
     if (!parent.isValid()) {
-        parentItem = m_tileManager->rootTile();
+        parentItem = static_cast<CustomTile *>(m_rootTile);
     } else {
         parentItem = static_cast<CustomTile *>(parent.internalPointer());
     }
@@ -92,7 +92,7 @@ QModelIndex TileModel::parent(const QModelIndex &index) const
     CustomTile *childItem = static_cast<CustomTile *>(index.internalPointer());
     CustomTile *parentItem = static_cast<CustomTile *>(childItem->parentTile());
 
-    if (!parentItem || parentItem == m_tileManager->rootTile()) {
+    if (!parentItem || parentItem == static_cast<CustomTile *>(m_rootTile)) {
         return QModelIndex();
     }
 
@@ -107,7 +107,7 @@ int TileModel::rowCount(const QModelIndex &parent) const
     }
 
     if (!parent.isValid()) {
-        parentItem = m_tileManager->rootTile();
+        parentItem = static_cast<CustomTile *>(m_rootTile);
     } else {
         parentItem = static_cast<CustomTile *>(parent.internalPointer());
     }
@@ -126,7 +126,7 @@ void TileModel::beginInsertTile(CustomTile *tile, int position)
     CustomTile *parentTile = static_cast<CustomTile *>(tile->parentTile());
     Q_ASSERT(parentTile);
 
-    auto index = parentTile == m_tileManager->rootTile() ? QModelIndex() : createIndex(parentTile->row(), 0, parentTile);
+    auto index = parentTile == tile->rootTile() ? QModelIndex() : createIndex(parentTile->row(), 0, parentTile);
     const int pos = std::clamp(position, 0, parentTile->childCount());
 
     beginInsertRows(index, pos, pos);
@@ -145,7 +145,7 @@ void TileModel::beginRemoveTile(CustomTile *tile)
         return;
     }
 
-    QModelIndex parentIndex = parentTile == m_tileManager->rootTile() ? QModelIndex() : createIndex(parentTile->row(), 0, parentTile);
+    QModelIndex parentIndex = parentTile == static_cast<CustomTile *>(m_rootTile) ? QModelIndex() : createIndex(parentTile->row(), 0, parentTile);
     beginRemoveRows(parentIndex, tile->row(), tile->row());
 }
 
diff --git a/src/scripting/tilemodel.h b/src/scripting/tilemodel.h
index 55aaa56cd7d..10de1e2e89b 100644
--- a/src/scripting/tilemodel.h
+++ b/src/scripting/tilemodel.h
@@ -9,7 +9,6 @@
 
 #pragma once
 
-#include "tiles/customtile.h"
 #include "tiles/tile.h"
 #include <kwin_export.h>
 
@@ -39,7 +38,7 @@ public:
     enum Roles {
         TileRole = Qt::UserRole + 1
     };
-    explicit TileModel(TileManager *parent = nullptr);
+    explicit TileModel(Tile *parent = nullptr);
     ~TileModel() override;
 
     // QAbstractItemModel overrides
@@ -59,7 +58,7 @@ private:
     void endRemoveTile();
 
     // Not an uinique_pointer as the model is child of the manager so would cause a cyclic delete
-    TileManager *m_tileManager;
+    Tile *m_rootTile;
     friend class CustomTile;
 
     Q_DISABLE_COPY(TileModel)
diff --git a/src/tiles/customtile.cpp b/src/tiles/customtile.cpp
index b29b4fb8fa9..71c18c03560 100644
--- a/src/tiles/customtile.cpp
+++ b/src/tiles/customtile.cpp
@@ -9,6 +9,7 @@
 
 #include "customtile.h"
 #include "core/output.h"
+#include "effect/globals.h"
 #include "tilemanager.h"
 #include "window.h"
 
@@ -42,9 +43,10 @@ CustomTile *CustomTile::createChildAt(const QRectF &relativeGeometry, LayoutDire
     connect(tile, &CustomTile::layoutModified, this, &CustomTile::layoutModified);
     tile->setRelativeGeometry(relativeGeometry);
     tile->setLayoutDirection(layoutDirection);
-    manager()->model()->beginInsertTile(tile, position);
+    TileModel *model = static_cast<RootTile *>(rootTile())->model();
+    model->beginInsertTile(tile, position);
     insertChild(position, tile);
-    manager()->model()->endInsertTile();
+    model->endInsertTile();
     return tile;
 }
 
@@ -277,10 +279,11 @@ void CustomTile::remove()
     auto *prev = previousSibling();
     auto *next = nextSibling();
 
-    manager()->model()->beginRemoveTile(this);
+    TileModel *model = static_cast<RootTile *>(rootTile())->model();
+    model->beginRemoveTile(this);
     parentT->removeChild(this);
     m_parentTile = nullptr;
-    manager()->model()->endRemoveTile();
+    model->endRemoveTile();
     manager()->tileRemoved(this);
 
     if (parentT->layoutDirection() == LayoutDirection::Horizontal) {
@@ -329,7 +332,10 @@ void CustomTile::remove()
 
     const auto windows = std::exchange(m_windows, {});
     for (Window *window : windows) {
-        window->requestTile(m_tiling->bestTileForPosition(window->moveResizeGeometry().center()));
+        Tile *tile = m_tiling->bestTileForPosition(window->moveResizeGeometry().center());
+        if (tile) {
+            tile->addWindow(window);
+        }
     }
 
     deleteLater(); // not using "delete this" because QQmlEngine will crash
@@ -421,13 +427,35 @@ Tile::LayoutDirection CustomTile::layoutDirection() const
     return m_layoutDirection;
 }
 
-RootTile::RootTile(TileManager *tiling)
+RootTile::RootTile(TileManager *tiling, VirtualDesktop *desktop)
     : CustomTile(tiling, nullptr)
+    , m_tileModel(new TileModel(this))
 {
+    m_desktop = desktop;
     setParent(tiling);
     setRelativeGeometry({0, 0, 1, 1});
 }
 
+Tile *RootTile::tileForWindow(Window *window)
+{
+    if (windows().contains(window)) {
+        return this;
+    }
+
+    for (Tile *tile : descendants()) {
+        if (tile->windows().contains(window)) {
+            return tile;
+        }
+    }
+
+    return nullptr;
+}
+
+TileModel *RootTile::model() const
+{
+    return m_tileModel.get();
+}
+
 } // namespace KWin
 
 #include "moc_customtile.cpp"
diff --git a/src/tiles/customtile.h b/src/tiles/customtile.h
index f252809dfbc..5f7c523f583 100644
--- a/src/tiles/customtile.h
+++ b/src/tiles/customtile.h
@@ -9,6 +9,7 @@
 
 #pragma once
 
+#include "scripting/tilemodel.h"
 #include "tile.h"
 
 #include <kwin_export.h>
@@ -61,7 +62,14 @@ class RootTile : public CustomTile
 {
     Q_OBJECT
 public:
-    RootTile(TileManager *tiling);
+    RootTile(TileManager *tiling, VirtualDesktop *desktop);
+
+    Tile *tileForWindow(Window *window);
+
+    TileModel *model() const;
+
+private:
+    std::unique_ptr<TileModel> m_tileModel = nullptr;
 };
 
 KWIN_EXPORT QDebug operator<<(QDebug debug, const CustomTile *tile);
diff --git a/src/tiles/quicktile.cpp b/src/tiles/quicktile.cpp
index 02caf307138..2f3e372c331 100644
--- a/src/tiles/quicktile.cpp
+++ b/src/tiles/quicktile.cpp
@@ -8,13 +8,17 @@
 */
 
 #include "quicktile.h"
+#include "tilemanager.h"
+#include "virtualdesktops.h"
 
 namespace KWin
 {
 
-QuickRootTile::QuickRootTile(TileManager *tiling, Tile *parentItem)
-    : Tile(tiling, parentItem)
+QuickRootTile::QuickRootTile(TileManager *tiling, VirtualDesktop *desktop)
+    : Tile(tiling, nullptr)
 {
+    m_desktop = desktop;
+    setParent(tiling);
     setPadding(0.0);
     setRelativeGeometry(QRectF(0, 0, 1, 1));
     setQuickTileMode(QuickTileFlag::None);
@@ -229,6 +233,25 @@ void QuickRootTile::tryReset()
     }
 }
 
+Tile *QuickRootTile::tileForWindow(Window *window) const
+{
+    Tile *allTiles[] = {m_leftVerticalTile.get(),
+                        m_rightVerticalTile.get(),
+                        m_topHorizontalTile.get(),
+                        m_bottomHorizontalTile.get(),
+                        m_topLeftTile.get(),
+                        m_topRightTile.get(),
+                        m_bottomLeftTile.get(),
+                        m_bottomRightTile.get()};
+
+    for (Tile *tile : allTiles) {
+        if (tile->windows().contains(window)) {
+            return tile;
+        }
+    }
+    return nullptr;
+}
+
 } // namespace KWin
 
 #include "moc_quicktile.cpp"
diff --git a/src/tiles/quicktile.h b/src/tiles/quicktile.h
index 9a2365bdd4b..7146e2b5bbc 100644
--- a/src/tiles/quicktile.h
+++ b/src/tiles/quicktile.h
@@ -16,11 +16,13 @@
 namespace KWin
 {
 
+class VirtualDesktop;
+
 class KWIN_EXPORT QuickRootTile : public Tile
 {
     Q_OBJECT
 public:
-    QuickRootTile(TileManager *tiling, Tile *parentItem = nullptr);
+    QuickRootTile(TileManager *tiling, VirtualDesktop *desktop);
     ~QuickRootTile();
 
     Tile *tileForMode(QuickTileMode mode);
@@ -32,6 +34,8 @@ public:
     qreal verticalSplit() const;
     void setVerticalSplit(qreal split);
 
+    Tile *tileForWindow(Window *window) const;
+
 private:
     void relayoutToFit(Tile *tile);
     void tryReset();
diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index a958d62294f..a26098379fe 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -9,6 +9,7 @@
 
 #include "tile.h"
 #include "core/output.h"
+#include "effect/globals.h"
 #include "tilemanager.h"
 #include "virtualdesktops.h"
 #include "window.h"
@@ -28,8 +29,28 @@ Tile::Tile(TileManager *tiling, Tile *parent)
 {
     if (m_parentTile) {
         m_padding = m_parentTile->padding();
+        m_desktop = m_parentTile->desktop();
     }
     connect(Workspace::self(), &Workspace::configChanged, this, &Tile::windowGeometryChanged);
+    connect(Workspace::self(), &Workspace::windowRemoved, this, &Tile::removeWindow);
+
+    connect(m_tiling, &TileManager::tileForWindowChanged, this,
+            [this](Window *window, Tile *owner) {
+        // We only care when the owner on another desktop changed
+        // And we only want to synchronize non-custom types of tiles
+        if (owner == this || m_quickTileMode == QuickTileFlag::Custom) {
+            return;
+        }
+
+        // There is a new owner: we want to copy it in this desktop
+        // to have the same quickTileMode
+        if (owner && owner->quickTileMode() == m_quickTileMode) {
+            addWindow(window);
+        } else {
+            // Lost the owner: the "global" QuickTileMode becomes null
+            removeWindow(window);
+        }
+    });
 }
 
 Tile::~Tile()
@@ -45,12 +66,26 @@ Tile::~Tile()
     if (m_tiling->tearingDown()) {
         return;
     }
-    for (auto *w : std::as_const(m_windows)) {
+    auto windows = m_windows;
+    for (auto *w : windows) {
         Tile *tile = m_tiling->bestTileForPosition(w->moveResizeGeometry().center());
-        w->requestTile(tile);
+        removeWindow(w);
+        if (tile) {
+            tile->addWindow(w);
+        }
     }
 }
 
+VirtualDesktop *Tile::desktop() const
+{
+    return m_desktop;
+}
+
+bool Tile::isActive() const
+{
+    return m_desktop == VirtualDesktopManager::self()->currentDesktop();
+}
+
 bool Tile::supportsResizeGravity(Gravity gravity)
 {
     if (!m_parentTile) {
@@ -112,8 +147,11 @@ void Tile::setRelativeGeometry(const QRectF &geom)
     Q_EMIT absoluteGeometryChanged();
     Q_EMIT windowGeometryChanged();
 
-    for (auto *w : std::as_const(m_windows)) {
-        w->moveResize(windowGeometry());
+    if (isActive()) {
+        for (auto *w : std::as_const(m_windows)) {
+            // Resize only if we are the currently managing tile for that window
+            w->moveResize(windowGeometry());
+        }
     }
 }
 
@@ -150,13 +188,13 @@ QRectF Tile::windowGeometry() const
     effectiveMargins.setBottom(m_relativeGeometry.bottom() < 1.0 ? m_padding / 2.0 : m_padding);
 
     const auto geom = absoluteGeometry();
-    return geom.intersected(workspace()->clientArea(MaximizeArea, m_tiling->output(), VirtualDesktopManager::self()->currentDesktop())) - effectiveMargins;
+    return geom.intersected(workspace()->clientArea(MaximizeArea, m_tiling->output(), m_desktop)) - effectiveMargins;
 }
 
 QRectF Tile::maximizedWindowGeometry() const
 {
     const auto geom = absoluteGeometry();
-    return geom.intersected(workspace()->clientArea(MaximizeArea, m_tiling->output(), VirtualDesktopManager::self()->currentDesktop()));
+    return geom.intersected(workspace()->clientArea(MaximizeArea, m_tiling->output(), m_desktop));
 }
 
 Qt::Edges Tile::anchors() const
@@ -210,8 +248,11 @@ void Tile::setPadding(qreal padding)
     for (auto *t : std::as_const(m_children)) {
         t->setPadding(padding);
     }
-    for (auto *w : std::as_const(m_windows)) {
-        w->moveResize(windowGeometry());
+    if (isActive()) {
+        for (auto *w : std::as_const(m_windows)) {
+            // Resize only if we are the currently managing tile for that window
+            w->moveResize(windowGeometry());
+        }
     }
 
     Q_EMIT paddingChanged(padding);
@@ -228,6 +269,18 @@ void Tile::setQuickTileMode(QuickTileMode mode)
     m_quickTileMode = mode;
 }
 
+Tile *Tile::rootTile() const
+{
+    if (!m_parentTile) {
+        return const_cast<Tile *>(this);
+    }
+    Tile *candidate = m_parentTile;
+    while (candidate->parentTile()) {
+        candidate = candidate->parentTile();
+    }
+    return candidate;
+}
+
 void Tile::resizeFromGravity(Gravity gravity, int x_root, int y_root)
 {
     if (!m_parentTile) {
@@ -305,26 +358,57 @@ void Tile::resizeByPixels(qreal delta, Qt::Edge edge)
     setRelativeGeometry(newGeom);
 }
 
-void Tile::addWindow(Window *window)
+bool Tile::addWindow(Window *window)
 {
     if (!window->isClient()) {
-        return;
+        return false;
     }
-    if (!m_windows.contains(window)) {
-        // Don't resize the window here, it was already resized in the configureEvent
-        m_windows.append(window);
-        Q_EMIT windowAdded(window);
-        Q_EMIT windowsChanged();
+
+    if (m_windows.contains(window)) {
+        return true;
+    }
+
+    // If the window is not on the same tile's desktop
+    // it can't be added
+    if (!window->isOnDesktop(m_desktop)) {
+        return false;
     }
+
+    // There can be only one window owner per root tile, so make it forget
+    // if anybody else had the association
+    for (Tile *tile : rootTile()->descendants()) {
+        tile->removeWindow(window);
+    }
+
+    // Needs to be added before setAssociation to avoid double insertions
+    m_windows.append(window);
+
+    Q_EMIT windowAdded(window);
+    Q_EMIT windowsChanged();
+    Q_EMIT m_tiling->tileForWindowChanged(window, this);
+
+    // We can actually manage the window geometry if our desktop is current
+    // or if our desktop is the only desktop the window is in
+    if (isActive()) {
+        window->requestTile(this);
+    }
+    return true;
 }
 
-void Tile::removeWindow(Window *window)
+bool Tile::removeWindow(Window *window)
 {
     // We already ensure there is a single copy of window in m_windows
     if (m_windows.removeOne(window)) {
         Q_EMIT windowRemoved(window);
         Q_EMIT windowsChanged();
+        Q_EMIT m_tiling->tileForWindowChanged(window, nullptr);
+
+        if (window->requestedTile() == this) {
+            window->requestTile(nullptr);
+        }
+        return true;
     }
+    return false;
 }
 
 QList<KWin::Window *> Tile::windows() const
@@ -342,9 +426,13 @@ void Tile::insertChild(int position, Tile *item)
 
     if (wasEmpty) {
         Q_EMIT isLayoutChanged(true);
-        for (auto *w : std::as_const(m_windows)) {
+        auto windows = m_windows;
+        for (auto *w : windows) {
             Tile *tile = m_tiling->bestTileForPosition(w->moveResizeGeometry().center());
-            w->requestTile(tile);
+            removeWindow(w);
+            if (tile) {
+                tile->addWindow(w);
+            }
         }
     }
 
@@ -405,10 +493,10 @@ Tile *Tile::parentTile() const
     return m_parentTile;
 }
 
-void Tile::visitDescendants(std::function<void(const Tile *child)> callback) const
+void Tile::visitDescendants(std::function<void(Tile *child)> callback)
 {
     callback(this);
-    for (const Tile *child : m_children) {
+    for (Tile *child : m_children) {
         child->visitDescendants(callback);
     }
 }
diff --git a/src/tiles/tile.h b/src/tiles/tile.h
index 5482779b159..b95ea7ad6ef 100644
--- a/src/tiles/tile.h
+++ b/src/tiles/tile.h
@@ -10,6 +10,7 @@
 #pragma once
 
 #include "effect/globals.h"
+#include "virtualdesktops.h"
 #include <kwin_export.h>
 #include <utils/common.h>
 
@@ -20,6 +21,7 @@ namespace KWin
 {
 
 class TileManager;
+class VirtualDesktop;
 class Window;
 
 class KWIN_EXPORT Tile : public QObject
@@ -47,6 +49,9 @@ public:
     explicit Tile(TileManager *tiling, Tile *parentItem = nullptr);
     ~Tile();
 
+    VirtualDesktop *desktop() const;
+    bool isActive() const;
+
     void setGeometryFromWindow(const QRectF &geom);
     void setGeometryFromAbsolute(const QRectF &geom);
     virtual void setRelativeGeometry(const QRectF &geom);
@@ -93,6 +98,8 @@ public:
     QuickTileMode quickTileMode() const;
     void setQuickTileMode(QuickTileMode mode);
 
+    Tile *rootTile() const;
+
     /**
      * All tiles directly children of this tile
      */
@@ -106,14 +113,14 @@ public:
     /**
      * Visit all tiles descendant of this tile, recursive
      */
-    void visitDescendants(std::function<void(const Tile *child)> callback) const;
+    void visitDescendants(std::function<void(Tile *child)> callback);
 
     void resizeFromGravity(Gravity gravity, int x_root, int y_root);
 
     Q_INVOKABLE void resizeByPixels(qreal delta, Qt::Edge edge);
 
-    void addWindow(Window *window);
-    void removeWindow(Window *window);
+    Q_INVOKABLE bool addWindow(Window *window);
+    Q_INVOKABLE bool removeWindow(Window *window);
     QList<KWin::Window *> windows() const;
 
     int row() const;
@@ -141,6 +148,7 @@ public:
     }
 
 Q_SIGNALS:
+    void activeChanged(bool active);
     void relativeGeometryChanged();
     void absoluteGeometryChanged();
     void windowGeometryChanged();
@@ -160,6 +168,7 @@ protected:
     QList<Window *> m_windows;
     Tile *m_parentTile;
 
+    VirtualDesktop *m_desktop = nullptr;
     TileManager *m_tiling;
     QRectF m_relativeGeometry;
     static QSizeF s_minimumSize;
diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index 7cc40ab6f3a..8afd91186db 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -11,6 +11,7 @@
 #include "core/output.h"
 #include "quicktile.h"
 #include "virtualdesktops.h"
+#include "window.h"
 #include "workspace.h"
 
 #include <KConfigGroup>
@@ -28,7 +29,7 @@ namespace KWin
 QDebug operator<<(QDebug debug, const TileManager *tileManager)
 {
     if (tileManager) {
-        QList<Tile *> tiles({tileManager->rootTile()});
+        QList<Tile *> tiles({tileManager->rootTile(VirtualDesktopManager::self()->currentDesktop())});
         QList<Tile *> tilePath;
         QString indent(QStringLiteral("|-"));
         debug << tileManager->metaObject()->className() << '(' << static_cast<const void *>(tileManager) << ')' << '\n';
@@ -56,21 +57,51 @@ QDebug operator<<(QDebug debug, const TileManager *tileManager)
 TileManager::TileManager(Output *parent)
     : QObject(parent)
     , m_output(parent)
-    , m_tileModel(new TileModel(this))
 {
     m_saveTimer = std::make_unique<QTimer>(this);
     m_saveTimer->setSingleShot(true);
     m_saveTimer->setInterval(2000);
     connect(m_saveTimer.get(), &QTimer::timeout, this, &TileManager::saveSettings);
 
-    m_rootTile = std::make_unique<RootTile>(this);
-    m_rootTile->setRelativeGeometry(QRectF(0, 0, 1, 1));
-    connect(m_rootTile.get(), &CustomTile::paddingChanged, m_saveTimer.get(), static_cast<void (QTimer::*)()>(&QTimer::start));
-    connect(m_rootTile.get(), &CustomTile::layoutModified, m_saveTimer.get(), static_cast<void (QTimer::*)()>(&QTimer::start));
+    auto addDesktop = [this](VirtualDesktop *desk) {
+        RootTile *rootTile = new RootTile(this, desk);
+        m_rootTiles[desk] = rootTile;
+        m_quickRootTiles[desk] = new QuickRootTile(this, desk);
 
-    m_quickRootTile = std::make_unique<QuickRootTile>(this);
+        rootTile->setRelativeGeometry(QRectF(0, 0, 1, 1));
+        connect(rootTile, &CustomTile::paddingChanged, m_saveTimer.get(), static_cast<void (QTimer::*)()>(&QTimer::start));
+        connect(rootTile, &CustomTile::layoutModified, m_saveTimer.get(), static_cast<void (QTimer::*)()>(&QTimer::start));
 
-    readSettings();
+        readSettings(rootTile);
+    };
+
+    for (VirtualDesktop *desk : VirtualDesktopManager::self()->desktops()) {
+        addDesktop(desk);
+    }
+
+    m_rootTile = m_rootTiles[VirtualDesktopManager::self()->currentDesktop()];
+    m_quickRootTile = m_quickRootTiles[VirtualDesktopManager::self()->currentDesktop()];
+
+    connect(VirtualDesktopManager::self(), &VirtualDesktopManager::desktopAdded, this, addDesktop);
+    connect(VirtualDesktopManager::self(), &VirtualDesktopManager::desktopRemoved,
+            this, [this](VirtualDesktop *desk) {
+        delete m_rootTiles[desk];
+        delete m_quickRootTiles[desk];
+        m_rootTiles.remove(desk);
+        m_quickRootTiles.remove(desk);
+    });
+    connect(VirtualDesktopManager::self(), &VirtualDesktopManager::currentChanged,
+            this, [this](VirtualDesktop *oldDesk, VirtualDesktop *newDesk) {
+        m_rootTile = m_rootTiles[newDesk];
+        m_quickRootTile = m_quickRootTiles[newDesk];
+        Q_EMIT rootTileChanged(m_rootTile);
+        Q_EMIT modelChanged(m_rootTile->model());
+
+        const QList<Window *> windows = Workspace::self()->windows();
+        for (auto *w : windows) {
+            w->requestTile(tileForWindow(w, newDesk));
+        }
+    });
 }
 
 TileManager::~TileManager()
@@ -118,9 +149,14 @@ Tile *TileManager::bestTileForPosition(qreal x, qreal y)
     return bestTileForPosition({x, y});
 }
 
+CustomTile *TileManager::rootTile(VirtualDesktop *desktop) const
+{
+    return m_rootTiles.value(desktop);
+}
+
 CustomTile *TileManager::rootTile() const
 {
-    return m_rootTile.get();
+    return m_rootTile;
 }
 
 Tile *TileManager::quickTile(QuickTileMode mode) const
@@ -130,7 +166,45 @@ Tile *TileManager::quickTile(QuickTileMode mode) const
 
 TileModel *TileManager::model() const
 {
-    return m_tileModel.get();
+    return m_rootTile->model();
+}
+
+Tile *TileManager::tileForWindow(Window *window, VirtualDesktop *desktop)
+{
+    if (!window || !desktop) {
+        return nullptr;
+    }
+    Q_ASSERT(m_rootTiles.contains(desktop));
+    Q_ASSERT(m_quickRootTiles.contains(desktop));
+
+    Tile *owner = m_quickRootTiles[desktop]->tileForWindow(window);
+    if (owner) {
+        return owner;
+    }
+    return m_rootTiles[desktop]->tileForWindow(window);
+}
+
+void TileManager::forgetWindow(Window *window, VirtualDesktop *desktop)
+{
+    if (!window) {
+        return;
+    }
+
+    if (desktop) {
+        Tile *owner = tileForWindow(window, desktop);
+        if (owner) {
+            owner->removeWindow(window);
+        }
+        return;
+    }
+
+    const QList<VirtualDesktop *> desktops = VirtualDesktopManager::self()->desktops();
+    for (VirtualDesktop *desk : desktops) {
+        Tile *owner = tileForWindow(window, desk);
+        if (owner) {
+            owner->removeWindow(window);
+        }
+    }
 }
 
 Tile::LayoutDirection strToLayoutDirection(const QString &dir)
@@ -224,21 +298,25 @@ CustomTile *TileManager::parseTilingJSon(const QJsonValue &val, const QRectF &av
     return nullptr;
 }
 
-void TileManager::readSettings()
+void TileManager::readSettings(RootTile *rootTile)
 {
     KConfigGroup cg = kwinApp()->config()->group(QStringLiteral("Tiling"));
     qreal padding = cg.readEntry("padding", 4);
+    VirtualDesktop *desk = rootTile->desktop();
     cg = KConfigGroup(&cg, m_output->uuid().toString(QUuid::WithoutBraces));
+    cg = KConfigGroup(&cg, desk->id());
 
-    auto createDefaultSetup = [this]() {
-        Q_ASSERT(m_rootTile->childCount() == 0);
+    Q_ASSERT(m_rootTiles.contains(desk));
+
+    auto createDefaultSetup = [this](RootTile *rootTile) {
+        Q_ASSERT(rootTile->childCount() == 0);
         // If empty create an horizontal 3 columns layout
-        m_rootTile->setLayoutDirection(Tile::LayoutDirection::Horizontal);
-        m_rootTile->split(Tile::LayoutDirection::Horizontal);
-        static_cast<CustomTile *>(m_rootTile->childTile(0))->split(Tile::LayoutDirection::Horizontal);
-        Q_ASSERT(m_rootTile->childCount() == 3);
+        rootTile->setLayoutDirection(Tile::LayoutDirection::Horizontal);
+        rootTile->split(Tile::LayoutDirection::Horizontal);
+        static_cast<CustomTile *>(rootTile->childTile(0))->split(Tile::LayoutDirection::Horizontal);
+        Q_ASSERT(rootTile->childCount() == 3);
         // Resize middle column, the other two will be auto resized accordingly
-        m_rootTile->childTile(1)->setRelativeGeometry({0.25, 0.0, 0.5, 1.0});
+        rootTile->childTile(1)->setRelativeGeometry({0.25, 0.0, 0.5, 1.0});
     };
 
     QJsonParseError error;
@@ -246,26 +324,26 @@ void TileManager::readSettings()
     if (tiles.isEmpty()) {
         qCDebug(KWIN_CORE) << "Empty tiles configuration for monitor" << m_output->uuid().toString(QUuid::WithoutBraces) << ":"
                            << "Creating default setup";
-        createDefaultSetup();
+        createDefaultSetup(rootTile);
         return;
     }
     QJsonDocument doc = QJsonDocument::fromJson(tiles, &error);
 
     if (error.error != QJsonParseError::NoError) {
         qCWarning(KWIN_CORE) << "Parse error in tiles configuration for monitor" << m_output->uuid().toString(QUuid::WithoutBraces) << ":" << error.errorString() << "Creating default setup";
-        createDefaultSetup();
+        createDefaultSetup(rootTile);
         return;
     }
 
     if (doc.object().contains(QStringLiteral("tiles"))) {
         const auto arr = doc.object().value(QStringLiteral("tiles"));
         if (arr.isArray() && arr.toArray().count() > 0) {
-            m_rootTile->setLayoutDirection(strToLayoutDirection(doc.object().value(QStringLiteral("layoutDirection")).toString()));
-            parseTilingJSon(arr, QRectF(0, 0, 1, 1), m_rootTile.get());
+            rootTile->setLayoutDirection(strToLayoutDirection(doc.object().value(QStringLiteral("layoutDirection")).toString()));
+            parseTilingJSon(arr, QRectF(0, 0, 1, 1), rootTile);
         }
     }
 
-    m_rootTile->setPadding(padding);
+    rootTile->setPadding(padding);
 }
 
 QJsonObject TileManager::tileToJSon(CustomTile *tile)
@@ -318,12 +396,18 @@ QJsonObject TileManager::tileToJSon(CustomTile *tile)
 
 void TileManager::saveSettings()
 {
-    auto obj = tileToJSon(m_rootTile.get());
-    QJsonDocument doc(obj);
     KConfigGroup cg = kwinApp()->config()->group(QStringLiteral("Tiling"));
     cg.writeEntry("padding", m_rootTile->padding());
     cg = KConfigGroup(&cg, m_output->uuid().toString(QUuid::WithoutBraces));
-    cg.writeEntry("tiles", doc.toJson(QJsonDocument::Compact));
+
+    for (auto it = m_rootTiles.constBegin(); it != m_rootTiles.constEnd(); it++) {
+        VirtualDesktop *desk = it.key();
+        RootTile *rootTile = it.value();
+        auto obj = tileToJSon(rootTile);
+        QJsonDocument doc(obj);
+        KConfigGroup tileGroup(&cg, desk->id());
+        tileGroup.writeEntry("tiles", doc.toJson(QJsonDocument::Compact));
+    }
     cg.sync(); // FIXME: less frequent?
 }
 
diff --git a/src/tiles/tilemanager.h b/src/tiles/tilemanager.h
index d3838ae7ea8..4b3100d516a 100644
--- a/src/tiles/tilemanager.h
+++ b/src/tiles/tilemanager.h
@@ -37,8 +37,8 @@ class TileModel;
 class KWIN_EXPORT TileManager : public QObject
 {
     Q_OBJECT
-    Q_PROPERTY(KWin::Tile *rootTile READ rootTile CONSTANT)
-    Q_PROPERTY(TileModel *model READ model CONSTANT)
+    Q_PROPERTY(KWin::Tile *rootTile READ rootTile NOTIFY rootTileChanged)
+    Q_PROPERTY(TileModel *model READ model NOTIFY modelChanged)
 
 public:
     explicit TileManager(Output *parent = nullptr);
@@ -50,16 +50,23 @@ public:
 
     KWin::Tile *bestTileForPosition(const QPointF &pos);
     Q_INVOKABLE KWin::Tile *bestTileForPosition(qreal x, qreal y); // For scripting
+    CustomTile *rootTile(VirtualDesktop *desktop) const;
     CustomTile *rootTile() const;
     KWin::Tile *quickTile(QuickTileMode mode) const;
 
     TileModel *model() const;
 
+    Tile *tileForWindow(Window *window, VirtualDesktop *desktop);
+    void forgetWindow(Window *window, VirtualDesktop *desktop);
+
 Q_SIGNALS:
     void tileRemoved(KWin::Tile *tile);
+    void tileForWindowChanged(Window *window, Tile *owner);
+    void rootTileChanged(CustomTile *rootTile);
+    void modelChanged(TileModel *model);
 
 private:
-    void readSettings();
+    void readSettings(RootTile *rootTile);
     void saveSettings();
     QJsonObject tileToJSon(CustomTile *parentTile);
     CustomTile *parseTilingJSon(const QJsonValue &val, const QRectF &availableArea, CustomTile *parentTile);
@@ -68,9 +75,12 @@ private:
 
     Output *m_output = nullptr;
     std::unique_ptr<QTimer> m_saveTimer;
-    std::unique_ptr<CustomTile> m_rootTile = nullptr;
-    std::unique_ptr<QuickRootTile> m_quickRootTile = nullptr;
-    std::unique_ptr<TileModel> m_tileModel = nullptr;
+    RootTile *m_rootTile = nullptr;
+    QuickRootTile *m_quickRootTile = nullptr;
+
+    QHash<VirtualDesktop *, RootTile *> m_rootTiles;
+    QHash<VirtualDesktop *, QuickRootTile *> m_quickRootTiles;
+
     bool m_tearingDown = false;
     friend class CustomTile;
 };
diff --git a/src/window.cpp b/src/window.cpp
index 3a13a67f3e8..c917557e720 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3812,10 +3812,18 @@ void Window::setQuickTileMode(QuickTileMode mode, const QPointF &tileAtPoint)
         mode &= ~QuickTileMode(QuickTileFlag::Vertical);
     }
 
+    Tile *tile = nullptr;
     if (mode == QuickTileMode(QuickTileFlag::Custom)) {
-        requestTile(workspace()->tileManager(workspace()->outputAt(tileAtPoint))->bestTileForPosition(tileAtPoint));
+        tile = workspace()->tileManager(workspace()->outputAt(tileAtPoint))->bestTileForPosition(tileAtPoint);
     } else {
-        requestTile(workspace()->tileManager(workspace()->outputAt(tileAtPoint))->quickTile(mode));
+        tile = workspace()->tileManager(workspace()->outputAt(tileAtPoint))->quickTile(mode);
+    }
+
+    if (!tile && m_requestedTile) {
+        m_requestedTile->removeWindow(this);
+    }
+    if (tile) {
+        tile->addWindow(this);
     }
 }
 
@@ -3843,20 +3851,10 @@ void Window::commitTile(Tile *tile)
         return;
     }
 
-    Tile *oldTile = m_tile;
     QuickTileMode oldTileMode = quickTileMode();
 
     m_tile = tile;
 
-    if (m_tile) {
-        Q_ASSERT(!isDeleted());
-        m_tile->addWindow(this);
-    }
-
-    if (oldTile) {
-        oldTile->removeWindow(this);
-    }
-
     Q_EMIT tileChanged(tile);
 
     if (oldTileMode != quickTileMode()) {
@@ -3916,6 +3914,21 @@ void Window::requestTile(Tile *tile)
     Q_EMIT requestedTileChanged();
 }
 
+void Window::setTileCompatibility(Tile *tile)
+{
+    qCWarning(KWIN_CORE) << "Writing to the property window.tile is deprecated: use tile.addWindow() instead";
+
+    if (m_requestedTile == tile) {
+        return;
+    }
+
+    if (tile) {
+        tile->addWindow(this);
+    } else if (m_requestedTile) {
+        m_requestedTile->removeWindow(this);
+    }
+}
+
 void Window::doSetQuickTileMode()
 {
 }
@@ -3991,10 +4004,12 @@ void Window::sendToOutput(Output *newOutput)
     const QRectF screenArea = workspace()->clientArea(MaximizeArea, this, newOutput);
 
     if (requestedQuickTileMode() == QuickTileMode(QuickTileFlag::Custom)) {
-        requestTile(nullptr);
+        workspace()->tileManager(moveResizeOutput())->forgetWindow(this, nullptr);
     } else {
         Tile *newTile = workspace()->tileManager(newOutput)->quickTile(requestedQuickTileMode());
-        requestTile(newTile);
+        if (newTile) {
+            newTile->addWindow(this);
+        }
     }
 
     QRectF newGeom = moveToArea(oldGeom, oldScreenArea, screenArea);
diff --git a/src/window.h b/src/window.h
index 61a835ac348..2c11b01ef1c 100644
--- a/src/window.h
+++ b/src/window.h
@@ -551,7 +551,7 @@ class KWIN_EXPORT Window : public QObject
     /**
      * The Tile this window is associated to, if any
      */
-    Q_PROPERTY(KWin::Tile *tile READ requestedTile WRITE requestTile NOTIFY tileChanged)
+    Q_PROPERTY(KWin::Tile *tile READ requestedTile WRITE setTileCompatibility NOTIFY tileChanged)
 
     /**
      * Returns whether this window is a input method window.
@@ -1120,6 +1120,7 @@ public:
     void commitTile(Tile *tile);
     Tile *requestedTile() const;
     void requestTile(Tile *tile);
+    void setTileCompatibility(Tile *tile);
 
     void handleQuickTileShortcut(QuickTileMode mode);
     void setQuickTileModeAtCurrentPosition(QuickTileMode mode);
diff --git a/src/workspace.cpp b/src/workspace.cpp
index a8bb8c9e17c..ea0f64fff9c 100644
--- a/src/workspace.cpp
+++ b/src/workspace.cpp
@@ -1265,10 +1265,10 @@ void Workspace::updateOutputs(const std::optional<QList<Output *>> &outputOrder)
         m_tileManagers.erase(output);
 
         // Evacuate windows from the defunct custom tile tree.
-        tileManager->rootTile()->visitDescendants([](const Tile *child) {
+        tileManager->rootTile()->visitDescendants([](Tile *child) {
             const QList<Window *> windows = child->windows();
             for (Window *window : windows) {
-                window->requestTile(nullptr);
+                child->removeWindow(window);
             }
         });
 
@@ -1294,8 +1294,10 @@ void Workspace::updateOutputs(const std::optional<QList<Output *>> &outputOrder)
             Output *bestOutput = outputAt(output->geometry().center());
             Tile *bestTile = m_tileManagers[bestOutput]->quickTile(quickTileMode);
 
-            for (Window *window : windows) {
-                window->requestTile(bestTile);
+            if (bestTile) {
+                for (Window *window : windows) {
+                    bestTile->addWindow(window);
+                }
             }
         }
     }
-- 
GitLab


From 462c2c9978ed59742ade456243d5fca24470cd04 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Sun, 29 Dec 2024 23:14:24 +0200
Subject: [PATCH 02/32] Reapply "tiles: Set up proper quick tile tree
 hierarchy"

This reverts commit 7ade5bd79c128cb0686bf9ffe8190ee75570352e.
---
 src/tiles/quicktile.cpp | 71 ++++++++++++++++++++---------------------
 src/tiles/quicktile.h   | 16 +++++-----
 2 files changed, 43 insertions(+), 44 deletions(-)

diff --git a/src/tiles/quicktile.cpp b/src/tiles/quicktile.cpp
index 2f3e372c331..8c8dc939523 100644
--- a/src/tiles/quicktile.cpp
+++ b/src/tiles/quicktile.cpp
@@ -23,18 +23,17 @@ QuickRootTile::QuickRootTile(TileManager *tiling, VirtualDesktop *desktop)
     setRelativeGeometry(QRectF(0, 0, 1, 1));
     setQuickTileMode(QuickTileFlag::None);
 
-    auto createTile = [this, &tiling](const QRectF &geometry, QuickTileMode tileMode) {
-        Tile *tile = new Tile(tiling, this);
+    auto createTile = [this](const QRectF &geometry, QuickTileMode tileMode) {
+        Tile *tile = createChildAt<Tile>(geometry, childCount());
         tile->setPadding(0.0);
         tile->setQuickTileMode(tileMode);
-        tile->setRelativeGeometry(geometry);
 
         connect(tile, &Tile::relativeGeometryChanged, this, [this, tile]() {
             relayoutToFit(tile);
         });
         connect(tile, &Tile::windowRemoved, this, &QuickRootTile::tryReset);
 
-        return std::unique_ptr<Tile>(tile);
+        return tile;
     };
 
     m_leftVerticalTile = createTile(QRectF(0, 0, 0.5, 1), QuickTileFlag::Left);
@@ -62,24 +61,24 @@ void QuickRootTile::relayoutToFit(Tile *tile)
 
     const QRectF geometry = tile->relativeGeometry();
 
-    if (m_topHorizontalTile.get() == tile) {
+    if (m_topHorizontalTile == tile) {
         setVerticalSplit(geometry.bottom());
-    } else if (m_bottomHorizontalTile.get() == tile) {
+    } else if (m_bottomHorizontalTile == tile) {
         setVerticalSplit(geometry.top());
-    } else if (m_leftVerticalTile.get() == tile) {
+    } else if (m_leftVerticalTile == tile) {
         setHorizontalSplit(geometry.right());
-    } else if (m_rightVerticalTile.get() == tile) {
+    } else if (m_rightVerticalTile == tile) {
         setHorizontalSplit(geometry.left());
-    } else if (m_topLeftTile.get() == tile) {
+    } else if (m_topLeftTile == tile) {
         setHorizontalSplit(geometry.right());
         setVerticalSplit(geometry.bottom());
-    } else if (m_topRightTile.get() == tile) {
+    } else if (m_topRightTile == tile) {
         setHorizontalSplit(geometry.left());
         setVerticalSplit(geometry.bottom());
-    } else if (m_bottomRightTile.get() == tile) {
+    } else if (m_bottomRightTile == tile) {
         setHorizontalSplit(geometry.left());
         setVerticalSplit(geometry.top());
-    } else if (m_bottomLeftTile.get() == tile) {
+    } else if (m_bottomLeftTile == tile) {
         setHorizontalSplit(geometry.right());
         setVerticalSplit(geometry.top());
     }
@@ -91,21 +90,21 @@ Tile *QuickRootTile::tileForMode(QuickTileMode mode)
 {
     switch (mode) {
     case QuickTileMode(QuickTileFlag::Left):
-        return m_leftVerticalTile.get();
+        return m_leftVerticalTile;
     case QuickTileMode(QuickTileFlag::Right):
-        return m_rightVerticalTile.get();
+        return m_rightVerticalTile;
     case QuickTileMode(QuickTileFlag::Top):
-        return m_topHorizontalTile.get();
+        return m_topHorizontalTile;
     case QuickTileMode(QuickTileFlag::Bottom):
-        return m_bottomHorizontalTile.get();
+        return m_bottomHorizontalTile;
     case QuickTileMode(QuickTileFlag::Left | QuickTileFlag::Top):
-        return m_topLeftTile.get();
+        return m_topLeftTile;
     case QuickTileMode(QuickTileFlag::Right | QuickTileFlag::Top):
-        return m_topRightTile.get();
+        return m_topRightTile;
     case QuickTileMode(QuickTileFlag::Left | QuickTileFlag::Bottom):
-        return m_bottomLeftTile.get();
+        return m_bottomLeftTile;
     case QuickTileMode(QuickTileFlag::Right | QuickTileFlag::Bottom):
-        return m_bottomRightTile.get();
+        return m_bottomRightTile;
     default:
         return nullptr;
     }
@@ -115,21 +114,21 @@ Tile *QuickRootTile::tileForBorder(ElectricBorder border)
 {
     switch (border) {
     case ElectricTop:
-        return m_topHorizontalTile.get();
+        return m_topHorizontalTile;
     case ElectricTopRight:
-        return m_topRightTile.get();
+        return m_topRightTile;
     case ElectricRight:
-        return m_rightVerticalTile.get();
+        return m_rightVerticalTile;
     case ElectricBottomRight:
-        return m_bottomRightTile.get();
+        return m_bottomRightTile;
     case ElectricBottom:
-        return m_bottomHorizontalTile.get();
+        return m_bottomHorizontalTile;
     case ElectricBottomLeft:
-        return m_bottomLeftTile.get();
+        return m_bottomLeftTile;
     case ElectricLeft:
-        return m_leftVerticalTile.get();
+        return m_leftVerticalTile;
     case ElectricTopLeft:
-        return m_topLeftTile.get();
+        return m_topLeftTile;
     case ElectricNone:
     default:
         return nullptr;
@@ -235,14 +234,14 @@ void QuickRootTile::tryReset()
 
 Tile *QuickRootTile::tileForWindow(Window *window) const
 {
-    Tile *allTiles[] = {m_leftVerticalTile.get(),
-                        m_rightVerticalTile.get(),
-                        m_topHorizontalTile.get(),
-                        m_bottomHorizontalTile.get(),
-                        m_topLeftTile.get(),
-                        m_topRightTile.get(),
-                        m_bottomLeftTile.get(),
-                        m_bottomRightTile.get()};
+    Tile *allTiles[] = {m_leftVerticalTile,
+                        m_rightVerticalTile,
+                        m_topHorizontalTile,
+                        m_bottomHorizontalTile,
+                        m_topLeftTile,
+                        m_topRightTile,
+                        m_bottomLeftTile,
+                        m_bottomRightTile};
 
     for (Tile *tile : allTiles) {
         if (tile->windows().contains(window)) {
diff --git a/src/tiles/quicktile.h b/src/tiles/quicktile.h
index 7146e2b5bbc..6abb622740c 100644
--- a/src/tiles/quicktile.h
+++ b/src/tiles/quicktile.h
@@ -42,16 +42,16 @@ private:
 
     Tile *m_resizedTile = nullptr;
 
-    std::unique_ptr<Tile> m_leftVerticalTile;
-    std::unique_ptr<Tile> m_rightVerticalTile;
+    Tile *m_leftVerticalTile = nullptr;
+    Tile *m_rightVerticalTile = nullptr;
 
-    std::unique_ptr<Tile> m_topHorizontalTile;
-    std::unique_ptr<Tile> m_bottomHorizontalTile;
+    Tile *m_topHorizontalTile = nullptr;
+    Tile *m_bottomHorizontalTile = nullptr;
 
-    std::unique_ptr<Tile> m_topLeftTile;
-    std::unique_ptr<Tile> m_topRightTile;
-    std::unique_ptr<Tile> m_bottomLeftTile;
-    std::unique_ptr<Tile> m_bottomRightTile;
+    Tile *m_topLeftTile = nullptr;
+    Tile *m_topRightTile = nullptr;
+    Tile *m_bottomLeftTile = nullptr;
+    Tile *m_bottomRightTile = nullptr;
 };
 
 } // namespace KWin
-- 
GitLab


From f7192939202a5ad5b3999ec031267a21896a232d Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Sun, 29 Dec 2024 23:14:33 +0200
Subject: [PATCH 03/32] Reapply "tiling: change in config storage"

This reverts commit 9292524b3c64d99709c4c35eb755729ab2d73138.
---
 src/tiles/tilemanager.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index 8afd91186db..c4ba10648ff 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -303,8 +303,8 @@ void TileManager::readSettings(RootTile *rootTile)
     KConfigGroup cg = kwinApp()->config()->group(QStringLiteral("Tiling"));
     qreal padding = cg.readEntry("padding", 4);
     VirtualDesktop *desk = rootTile->desktop();
-    cg = KConfigGroup(&cg, m_output->uuid().toString(QUuid::WithoutBraces));
     cg = KConfigGroup(&cg, desk->id());
+    cg = KConfigGroup(&cg, m_output->uuid().toString(QUuid::WithoutBraces));
 
     Q_ASSERT(m_rootTiles.contains(desk));
 
@@ -398,7 +398,6 @@ void TileManager::saveSettings()
 {
     KConfigGroup cg = kwinApp()->config()->group(QStringLiteral("Tiling"));
     cg.writeEntry("padding", m_rootTile->padding());
-    cg = KConfigGroup(&cg, m_output->uuid().toString(QUuid::WithoutBraces));
 
     for (auto it = m_rootTiles.constBegin(); it != m_rootTiles.constEnd(); it++) {
         VirtualDesktop *desk = it.key();
@@ -406,6 +405,7 @@ void TileManager::saveSettings()
         auto obj = tileToJSon(rootTile);
         QJsonDocument doc(obj);
         KConfigGroup tileGroup(&cg, desk->id());
+        tileGroup = KConfigGroup(&tileGroup, m_output->uuid().toString(QUuid::WithoutBraces));
         tileGroup.writeEntry("tiles", doc.toJson(QJsonDocument::Compact));
     }
     cg.sync(); // FIXME: less frequent?
-- 
GitLab


From 3568ed3139383204ca7432360aaa3167975fe844 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 13 Dec 2024 13:06:13 +0200
Subject: [PATCH 04/32] autotests: Remove unused fields in QuickTilingTest

---
 autotests/integration/quick_tiling_test.cpp | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index a2e73a20a4f..7b63177bcc1 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -72,10 +72,6 @@ private Q_SLOTS:
     void testScript_data();
     void testScript();
     void testDontCrashWithMaximizeWindowRule();
-
-private:
-    KWayland::Client::ConnectionThread *m_connection = nullptr;
-    KWayland::Client::Compositor *m_compositor = nullptr;
 };
 
 void QuickTilingTest::initTestCase()
@@ -109,8 +105,6 @@ void QuickTilingTest::initTestCase()
 void QuickTilingTest::init()
 {
     QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::XdgDecorationV1));
-    m_connection = Test::waylandConnection();
-    m_compositor = Test::waylandCompositor();
 
     workspace()->setActiveOutput(QPoint(640, 512));
     input()->pointer()->warp(QPoint(640, 512));
-- 
GitLab


From 59a7d0a60d78ed27f0d23a3201db09a205066d89 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 12 Dec 2024 19:10:08 +0200
Subject: [PATCH 05/32] Fix multi screen quick tiling

When a quick tiled window is moved between the screens, it will migrate
between the tile trees. The Tile::addWindow() will evacuate the window
from the previous tile only if both tiles belong to the same tree. It's
not going to be the same when moving a window between outputs. We need to
handle it explicitly.
---
 autotests/integration/quick_tiling_test.cpp | 251 ++++++++++++++++++++
 src/tiles/tile.cpp                          |  16 +-
 src/tiles/tilemanager.cpp                   |   5 +
 src/tiles/tilemanager.h                     |   1 +
 src/window.cpp                              |  11 +-
 5 files changed, 277 insertions(+), 7 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index 7b63177bcc1..2ddf9d9b5dd 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -48,6 +48,32 @@ namespace KWin
 
 static const QString s_socketName = QStringLiteral("wayland_test_kwin_quick_tiling-0");
 
+static X11Window *createWindow(xcb_connection_t *connection, const QRect &geometry)
+{
+    xcb_window_t windowId = xcb_generate_id(connection);
+    xcb_create_window(connection, XCB_COPY_FROM_PARENT, windowId, rootWindow(),
+                      geometry.x(),
+                      geometry.y(),
+                      geometry.width(),
+                      geometry.height(),
+                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, XCB_COPY_FROM_PARENT, 0, nullptr);
+
+    xcb_size_hints_t hints;
+    memset(&hints, 0, sizeof(hints));
+    xcb_icccm_size_hints_set_position(&hints, 1, geometry.x(), geometry.y());
+    xcb_icccm_size_hints_set_size(&hints, 1, geometry.width(), geometry.height());
+    xcb_icccm_set_wm_normal_hints(connection, windowId, &hints);
+
+    xcb_map_window(connection, windowId);
+    xcb_flush(connection);
+
+    QSignalSpy windowCreatedSpy(workspace(), &Workspace::windowAdded);
+    if (!windowCreatedSpy.wait()) {
+        return nullptr;
+    }
+    return windowCreatedSpy.last().first().value<X11Window *>();
+}
+
 class QuickTilingTest : public QObject
 {
     Q_OBJECT
@@ -69,6 +95,8 @@ private Q_SLOTS:
     void testX11QuickTilingAfterVertMaximize();
     void testShortcut_data();
     void testShortcut();
+    void testMultiScreen();
+    void testMultiScreenX11();
     void testScript_data();
     void testScript();
     void testDontCrashWithMaximizeWindowRule();
@@ -799,6 +827,229 @@ void QuickTilingTest::testShortcut()
     QCOMPARE(window->frameGeometry(), expectedGeometry);
 }
 
+void QuickTilingTest::testMultiScreen()
+{
+    // This test verifies that a window can be moved between screens by continuously pressing Meta+arrow.
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    TileManager *firstTileManager = workspace()->tileManager(workspace()->outputs().at(0));
+    TileManager *secondTileManager = workspace()->tileManager(workspace()->outputs().at(1));
+
+    const struct
+    {
+        QuickTileMode shortcut;
+        QuickTileMode previous;
+        Tile *previousTile;
+        QuickTileMode next;
+        Tile *nextTile;
+        QRectF geometry;
+    } steps[] = {
+        // Not tiled -> tiled on the left half of the first screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::None,
+            .previousTile = nullptr,
+            .next = QuickTileFlag::Left,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(0, 0, 640, 1024),
+        },
+        // Tiled on the left half of the first screen -> tiled on the right half of the first screen
+        {
+            .shortcut = QuickTileFlag::Right,
+            .previous = QuickTileFlag::Left,
+            .previousTile = firstTileManager->quickTile(QuickTileFlag::Left),
+            .next = QuickTileFlag::Right,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .geometry = QRectF(640, 0, 640, 1024),
+        },
+        // Tiled on the right half of the first screen -> tiled on the left half of the second screen
+        {
+            .shortcut = QuickTileFlag::Right,
+            .previous = QuickTileFlag::Right,
+            .previousTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .next = QuickTileFlag::Left,
+            .nextTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(1280, 0, 640, 1024),
+        },
+        // Tiled on the left half of the second screen -> tiled on the right half of the second screen
+        {
+            .shortcut = QuickTileFlag::Right,
+            .previous = QuickTileFlag::Left,
+            .previousTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .next = QuickTileFlag::Right,
+            .nextTile = secondTileManager->quickTile(QuickTileFlag::Right),
+            .geometry = QRectF(1920, 0, 640, 1024),
+        },
+        // Tiled on the right half of the second screen -> tiled on the left half of the second screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::Right,
+            .previousTile = secondTileManager->quickTile(QuickTileFlag::Right),
+            .next = QuickTileFlag::Left,
+            .nextTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(1280, 0, 640, 1024),
+        },
+        // Tiled on the left half of the second screen -> tiled on the right half of the first screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::Left,
+            .previousTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .next = QuickTileFlag::Right,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .geometry = QRectF(640, 0, 640, 1024),
+        },
+        // Tiled on the right half of the first screen -> tiled on the left half of the first screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::Right,
+            .previousTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .next = QuickTileFlag::Left,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(0, 0, 640, 1024),
+        },
+    };
+
+    for (const auto &step : steps) {
+        window->handleQuickTileShortcut(step.shortcut);
+
+        QCOMPARE(window->quickTileMode(), step.previous);
+        QCOMPARE(window->requestedQuickTileMode(), step.next);
+
+        QCOMPARE(window->tile(), step.previousTile);
+        QVERIFY(!step.previousTile || !step.previousTile->windows().contains(window));
+        QCOMPARE(window->requestedTile(), step.nextTile);
+        QVERIFY(step.nextTile->windows().contains(window));
+
+        QCOMPARE(window->moveResizeGeometry(), step.geometry);
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->quickTileMode(), step.next);
+        QCOMPARE(window->requestedQuickTileMode(), step.next);
+        QCOMPARE(window->tile(), step.nextTile);
+        QCOMPARE(window->requestedTile(), step.nextTile);
+        QCOMPARE(window->frameGeometry(), step.geometry);
+        QCOMPARE(window->moveResizeGeometry(), step.geometry);
+    }
+}
+
+void QuickTilingTest::testMultiScreenX11()
+{
+    // This test verifies that an X11 window can be moved between screens by continuously pressing Meta+arrow.
+
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+
+    TileManager *firstTileManager = workspace()->tileManager(workspace()->outputs().at(0));
+    TileManager *secondTileManager = workspace()->tileManager(workspace()->outputs().at(1));
+
+    const struct
+    {
+        QuickTileMode shortcut;
+        QuickTileMode previous;
+        Tile *previousTile;
+        QuickTileMode next;
+        Tile *nextTile;
+        QRectF geometry;
+    } steps[] = {
+        // Not tiled -> tiled on the left half of the first screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::None,
+            .previousTile = nullptr,
+            .next = QuickTileFlag::Left,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(0, 0, 640, 1024),
+        },
+        // Tiled on the left half of the first screen -> tiled on the right half of the first screen
+        {
+            .shortcut = QuickTileFlag::Right,
+            .previous = QuickTileFlag::Left,
+            .previousTile = firstTileManager->quickTile(QuickTileFlag::Left),
+            .next = QuickTileFlag::Right,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .geometry = QRectF(640, 0, 640, 1024),
+        },
+        // Tiled on the right half of the first screen -> tiled on the left half of the second screen
+        {
+            .shortcut = QuickTileFlag::Right,
+            .previous = QuickTileFlag::Right,
+            .previousTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .next = QuickTileFlag::Left,
+            .nextTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(1280, 0, 640, 1024),
+        },
+        // Tiled on the left half of the second screen -> tiled on the right half of the second screen
+        {
+            .shortcut = QuickTileFlag::Right,
+            .previous = QuickTileFlag::Left,
+            .previousTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .next = QuickTileFlag::Right,
+            .nextTile = secondTileManager->quickTile(QuickTileFlag::Right),
+            .geometry = QRectF(1920, 0, 640, 1024),
+        },
+        // Tiled on the right half of the second screen -> tiled on the left half of the second screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::Right,
+            .previousTile = secondTileManager->quickTile(QuickTileFlag::Right),
+            .next = QuickTileFlag::Left,
+            .nextTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(1280, 0, 640, 1024),
+        },
+        // Tiled on the left half of the second screen -> tiled on the right half of the first screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::Left,
+            .previousTile = secondTileManager->quickTile(QuickTileFlag::Left),
+            .next = QuickTileFlag::Right,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .geometry = QRectF(640, 0, 640, 1024),
+        },
+        // Tiled on the right half of the first screen -> tiled on the left half of the first screen
+        {
+            .shortcut = QuickTileFlag::Left,
+            .previous = QuickTileFlag::Right,
+            .previousTile = firstTileManager->quickTile(QuickTileFlag::Right),
+            .next = QuickTileFlag::Left,
+            .nextTile = firstTileManager->quickTile(QuickTileFlag::Left),
+            .geometry = QRectF(0, 0, 640, 1024),
+        },
+    };
+
+    for (const auto &step : steps) {
+        QCOMPARE(window->quickTileMode(), step.previous);
+        QCOMPARE(window->requestedQuickTileMode(), step.previous);
+        QCOMPARE(window->tile(), step.previousTile);
+        QCOMPARE(window->requestedTile(), step.previousTile);
+
+        window->handleQuickTileShortcut(step.shortcut);
+
+        QVERIFY(!step.previousTile || !step.previousTile->windows().contains(window));
+        QVERIFY(step.nextTile->windows().contains(window));
+
+        QCOMPARE(window->moveResizeGeometry(), step.geometry);
+        QCOMPARE(window->quickTileMode(), step.next);
+        QCOMPARE(window->requestedQuickTileMode(), step.next);
+        QCOMPARE(window->tile(), step.nextTile);
+        QCOMPARE(window->requestedTile(), step.nextTile);
+        QCOMPARE(window->frameGeometry(), step.geometry);
+        QCOMPARE(window->moveResizeGeometry(), step.geometry);
+    }
+}
+
 void QuickTilingTest::testScript_data()
 {
     QTest::addColumn<QString>("action");
diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index a26098379fe..fbe003a0a6f 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -376,8 +376,20 @@ bool Tile::addWindow(Window *window)
 
     // There can be only one window owner per root tile, so make it forget
     // if anybody else had the association
-    for (Tile *tile : rootTile()->descendants()) {
-        tile->removeWindow(window);
+    const auto outputs = workspace()->outputs();
+    for (Output *output : outputs) {
+        if (TileManager *manager = workspace()->tileManager(output)) {
+            if (Tile *rootTile = manager->rootTile(m_desktop)) {
+                rootTile->visitDescendants([window](Tile *tile) {
+                    tile->removeWindow(window);
+                });
+            }
+            if (Tile *rootTile = manager->quickRootTile(m_desktop)) {
+                rootTile->visitDescendants([window](Tile *tile) {
+                    tile->removeWindow(window);
+                });
+            }
+        }
     }
 
     // Needs to be added before setAssociation to avoid double insertions
diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index c4ba10648ff..d616ff32dd9 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -159,6 +159,11 @@ CustomTile *TileManager::rootTile() const
     return m_rootTile;
 }
 
+QuickRootTile *TileManager::quickRootTile(VirtualDesktop *desktop) const
+{
+    return m_quickRootTiles.value(desktop);
+}
+
 Tile *TileManager::quickTile(QuickTileMode mode) const
 {
     return m_quickRootTile->tileForMode(mode);
diff --git a/src/tiles/tilemanager.h b/src/tiles/tilemanager.h
index 4b3100d516a..9fa6e5075c0 100644
--- a/src/tiles/tilemanager.h
+++ b/src/tiles/tilemanager.h
@@ -52,6 +52,7 @@ public:
     Q_INVOKABLE KWin::Tile *bestTileForPosition(qreal x, qreal y); // For scripting
     CustomTile *rootTile(VirtualDesktop *desktop) const;
     CustomTile *rootTile() const;
+    QuickRootTile *quickRootTile(VirtualDesktop *desktop) const;
     KWin::Tile *quickTile(QuickTileMode mode) const;
 
     TileModel *model() const;
diff --git a/src/window.cpp b/src/window.cpp
index c917557e720..8e91a639898 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3819,11 +3819,12 @@ void Window::setQuickTileMode(QuickTileMode mode, const QPointF &tileAtPoint)
         tile = workspace()->tileManager(workspace()->outputAt(tileAtPoint))->quickTile(mode);
     }
 
-    if (!tile && m_requestedTile) {
-        m_requestedTile->removeWindow(this);
-    }
-    if (tile) {
-        tile->addWindow(this);
+    if (m_requestedTile != tile) {
+        if (tile) {
+            tile->addWindow(this);
+        } else if (m_requestedTile) {
+            m_requestedTile->removeWindow(this);
+        }
     }
 }
 
-- 
GitLab


From 1eed4a64f92a4df20353fce56c08c9a1b44a746f Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 13 Dec 2024 15:42:01 +0200
Subject: [PATCH 06/32] Fix tile evacuation in Window::setTileCompatibility()

We need to call removeWindow() in order to preserve the compatibility.
---
 src/window.cpp | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/window.cpp b/src/window.cpp
index 8e91a639898..63c7a02d393 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3923,10 +3923,13 @@ void Window::setTileCompatibility(Tile *tile)
         return;
     }
 
+    Tile *previousTile = m_requestedTile;
     if (tile) {
         tile->addWindow(this);
-    } else if (m_requestedTile) {
-        m_requestedTile->removeWindow(this);
+    }
+
+    if (previousTile) {
+        previousTile->removeWindow(this);
     }
 }
 
-- 
GitLab


From 75d1d2bce79f06e1a0a7cb1aa0815800da8ce8be Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 16 Dec 2024 15:48:54 +0200
Subject: [PATCH 07/32] Fix tile window evacuation in
 Workspace::updateOutputs()

Tiled windows need to be evacuated per virtual desktop now.
---
 src/workspace.cpp | 66 +++++++++++++++++++++++++----------------------
 1 file changed, 35 insertions(+), 31 deletions(-)

diff --git a/src/workspace.cpp b/src/workspace.cpp
index ea0f64fff9c..8ae3e9b71c7 100644
--- a/src/workspace.cpp
+++ b/src/workspace.cpp
@@ -1261,42 +1261,46 @@ void Workspace::updateOutputs(const std::optional<QList<Output *>> &outputOrder)
     const auto removed = oldOutputsSet - outputsSet;
     for (Output *output : removed) {
         Q_EMIT outputRemoved(output);
+
         auto tileManager = std::move(m_tileManagers[output]);
         m_tileManagers.erase(output);
 
-        // Evacuate windows from the defunct custom tile tree.
-        tileManager->rootTile()->visitDescendants([](Tile *child) {
-            const QList<Window *> windows = child->windows();
-            for (Window *window : windows) {
-                child->removeWindow(window);
-            }
-        });
-
-        // Migrate windows from the defunct quick tile to a quick tile tree on another output.
-        static constexpr QuickTileMode quickTileModes[] = {
-            QuickTileFlag::Left,
-            QuickTileFlag::Right,
-            QuickTileFlag::Top,
-            QuickTileFlag::Bottom,
-            QuickTileFlag::Top | QuickTileFlag::Left,
-            QuickTileFlag::Top | QuickTileFlag::Right,
-            QuickTileFlag::Bottom | QuickTileFlag::Left,
-            QuickTileFlag::Bottom | QuickTileFlag::Right,
-        };
-
-        for (const QuickTileMode &quickTileMode : quickTileModes) {
-            Tile *quickTile = tileManager->quickTile(quickTileMode);
-            const QList<Window *> windows = quickTile->windows();
-            if (windows.isEmpty()) {
-                continue;
-            }
+        const auto desktops = VirtualDesktopManager::self()->desktops();
+        for (VirtualDesktop *desktop : desktops) {
+            // Evacuate windows from the defunct custom tile tree.
+            tileManager->rootTile(desktop)->visitDescendants([](Tile *child) {
+                const QList<Window *> windows = child->windows();
+                for (Window *window : windows) {
+                    child->removeWindow(window);
+                }
+            });
+
+            // Migrate windows from the defunct quick tile to a quick tile tree on another output.
+            static constexpr QuickTileMode quickTileModes[] = {
+                QuickTileFlag::Left,
+                QuickTileFlag::Right,
+                QuickTileFlag::Top,
+                QuickTileFlag::Bottom,
+                QuickTileFlag::Top | QuickTileFlag::Left,
+                QuickTileFlag::Top | QuickTileFlag::Right,
+                QuickTileFlag::Bottom | QuickTileFlag::Left,
+                QuickTileFlag::Bottom | QuickTileFlag::Right,
+            };
+
+            for (const QuickTileMode &quickTileMode : quickTileModes) {
+                Tile *quickTile = tileManager->quickRootTile(desktop)->tileForMode(quickTileMode);
+                const QList<Window *> windows = quickTile->windows();
+                if (windows.isEmpty()) {
+                    continue;
+                }
 
-            Output *bestOutput = outputAt(output->geometry().center());
-            Tile *bestTile = m_tileManagers[bestOutput]->quickTile(quickTileMode);
+                Output *bestOutput = outputAt(output->geometry().center());
+                Tile *bestTile = m_tileManagers[bestOutput]->quickRootTile(desktop)->tileForMode(quickTileMode);
 
-            if (bestTile) {
-                for (Window *window : windows) {
-                    bestTile->addWindow(window);
+                if (bestTile) {
+                    for (Window *window : windows) {
+                        bestTile->addWindow(window);
+                    }
                 }
             }
         }
-- 
GitLab


From b977a5422188600f9e02b2a0133a684e8689e906 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 16 Dec 2024 16:23:21 +0200
Subject: [PATCH 08/32] tiles: Add Tile::forgetWindow()

---
 src/tiles/tile.cpp        | 10 ++++++++++
 src/tiles/tile.h          |  1 +
 src/tiles/tilemanager.cpp |  4 ++--
 src/window.cpp            | 10 ++++++++++
 src/window.h              |  1 +
 5 files changed, 24 insertions(+), 2 deletions(-)

diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index fbe003a0a6f..cb7260abf9e 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -423,6 +423,16 @@ bool Tile::removeWindow(Window *window)
     return false;
 }
 
+void Tile::forgetWindow(Window *window)
+{
+    if (m_windows.removeOne(window)) {
+        Q_EMIT windowRemoved(window);
+        Q_EMIT windowsChanged();
+
+        window->forgetTile(this);
+    }
+}
+
 QList<KWin::Window *> Tile::windows() const
 {
     return m_windows;
diff --git a/src/tiles/tile.h b/src/tiles/tile.h
index b95ea7ad6ef..c20e4442581 100644
--- a/src/tiles/tile.h
+++ b/src/tiles/tile.h
@@ -121,6 +121,7 @@ public:
 
     Q_INVOKABLE bool addWindow(Window *window);
     Q_INVOKABLE bool removeWindow(Window *window);
+    void forgetWindow(Window *window);
     QList<KWin::Window *> windows() const;
 
     int row() const;
diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index d616ff32dd9..7809830272c 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -198,7 +198,7 @@ void TileManager::forgetWindow(Window *window, VirtualDesktop *desktop)
     if (desktop) {
         Tile *owner = tileForWindow(window, desktop);
         if (owner) {
-            owner->removeWindow(window);
+            owner->forgetWindow(window);
         }
         return;
     }
@@ -207,7 +207,7 @@ void TileManager::forgetWindow(Window *window, VirtualDesktop *desktop)
     for (VirtualDesktop *desk : desktops) {
         Tile *owner = tileForWindow(window, desk);
         if (owner) {
-            owner->removeWindow(window);
+            owner->forgetWindow(window);
         }
     }
 }
diff --git a/src/window.cpp b/src/window.cpp
index 63c7a02d393..f10d7f5d423 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3915,6 +3915,16 @@ void Window::requestTile(Tile *tile)
     Q_EMIT requestedTileChanged();
 }
 
+void Window::forgetTile(Tile *tile)
+{
+    if (m_requestedTile != tile) {
+        return;
+    }
+
+    m_requestedTile = nullptr;
+    doSetQuickTileMode();
+}
+
 void Window::setTileCompatibility(Tile *tile)
 {
     qCWarning(KWIN_CORE) << "Writing to the property window.tile is deprecated: use tile.addWindow() instead";
diff --git a/src/window.h b/src/window.h
index 2c11b01ef1c..bfb82469c9e 100644
--- a/src/window.h
+++ b/src/window.h
@@ -1120,6 +1120,7 @@ public:
     void commitTile(Tile *tile);
     Tile *requestedTile() const;
     void requestTile(Tile *tile);
+    void forgetTile(Tile *tile);
     void setTileCompatibility(Tile *tile);
 
     void handleQuickTileShortcut(QuickTileMode mode);
-- 
GitLab


From 4cee3a31ba5853d1a34cc84caabf036385500ad7 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 16 Dec 2024 16:25:22 +0200
Subject: [PATCH 09/32] Fix mutual exclusivity between maximize and quick tile
 mode

A window cannot be both tiled and maximized. However, this assumption
is not always true due to the maximize() function not properly evacuating
the window from the requested tile.

This change makes sure that a maximized window properly leaves its tile
and adds relevant tests.

BUG: 497276
---
 autotests/integration/quick_tiling_test.cpp | 187 ++++++++++++++++++++
 src/window.cpp                              |  11 +-
 src/window.h                                |   2 +-
 src/x11window.cpp                           |  21 +--
 src/xdgshellwindow.cpp                      |   6 +-
 5 files changed, 201 insertions(+), 26 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index 2ddf9d9b5dd..6f1a26dd1e1 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -97,6 +97,8 @@ private Q_SLOTS:
     void testShortcut();
     void testMultiScreen();
     void testMultiScreenX11();
+    void testQuickTileAndMaximize();
+    void testQuickTileAndMaximizeX11();
     void testScript_data();
     void testScript();
     void testDontCrashWithMaximizeWindowRule();
@@ -1050,6 +1052,191 @@ void QuickTilingTest::testMultiScreenX11()
     }
 }
 
+void QuickTilingTest::testQuickTileAndMaximize()
+{
+    // This test verifies that quick tile and maximize mode are mutually exclusive.
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy maximizedChanged(window, &Window::maximizedChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    QuickTileMode previousQuickTileMode = QuickTileFlag::None;
+    MaximizeMode previousMaximizeMode = MaximizeRestore;
+
+    auto quickTile = [&]() {
+        window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Right);
+        QCOMPARE(window->geometryRestore(), QRectF(0, 0, 100, 100));
+        QCOMPARE(window->quickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+        QCOMPARE(window->maximizeMode(), previousMaximizeMode);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeRestore);
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+        QCOMPARE(window->maximizeMode(), MaximizeRestore);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeRestore);
+        QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+        QCOMPARE(window->moveResizeGeometry(), QRectF(640, 0, 640, 1024));
+
+        previousMaximizeMode = window->maximizeMode();
+        previousQuickTileMode = window->quickTileMode();
+    };
+
+    auto maximize = [&]() {
+        window->maximize(MaximizeFull);
+        QCOMPARE(window->geometryRestore(), QRectF(0, 0, 100, 100));
+        QCOMPARE(window->quickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->maximizeMode(), previousMaximizeMode);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeFull);
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(maximizedChanged.wait());
+        QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->maximizeMode(), MaximizeFull);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeFull);
+        QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+        QCOMPARE(window->moveResizeGeometry(), QRectF(0, 0, 1280, 1024));
+
+        previousMaximizeMode = window->maximizeMode();
+        previousQuickTileMode = window->quickTileMode();
+    };
+
+    auto restore = [&]() {
+        window->maximize(MaximizeRestore);
+        QCOMPARE(window->geometryRestore(), QRectF(0, 0, 100, 100));
+        QCOMPARE(window->quickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->maximizeMode(), previousMaximizeMode);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeRestore);
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(maximizedChanged.wait());
+        QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->maximizeMode(), MaximizeRestore);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeRestore);
+        QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
+        QCOMPARE(window->moveResizeGeometry(), QRectF(0, 0, 100, 100));
+
+        previousMaximizeMode = window->maximizeMode();
+        previousQuickTileMode = window->quickTileMode();
+    };
+
+    quickTile();
+    maximize();
+    restore();
+
+    quickTile();
+    maximize();
+    restore();
+
+    quickTile();
+    maximize();
+    quickTile();
+    maximize();
+}
+
+void QuickTilingTest::testQuickTileAndMaximizeX11()
+{
+    // This test verifies that quick tile and maximize mode are mutually exclusive.
+
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+
+    QuickTileMode previousQuickTileMode = QuickTileFlag::None;
+    MaximizeMode previousMaximizeMode = MaximizeRestore;
+    QRectF originalGeometry = window->frameGeometry();
+
+    auto quickTile = [&]() {
+        QCOMPARE(window->geometryRestore(), originalGeometry);
+        QCOMPARE(window->quickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->requestedQuickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->maximizeMode(), previousMaximizeMode);
+        QCOMPARE(window->requestedMaximizeMode(), previousMaximizeMode);
+
+        window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Right);
+
+        QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+        QCOMPARE(window->maximizeMode(), MaximizeRestore);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeRestore);
+        QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+        QCOMPARE(window->moveResizeGeometry(), QRectF(640, 0, 640, 1024));
+
+        previousMaximizeMode = window->maximizeMode();
+        previousQuickTileMode = window->quickTileMode();
+    };
+
+    auto maximize = [&]() {
+        QCOMPARE(window->geometryRestore(), originalGeometry);
+        QCOMPARE(window->quickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->requestedQuickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->maximizeMode(), previousMaximizeMode);
+        QCOMPARE(window->requestedMaximizeMode(), previousMaximizeMode);
+
+        window->maximize(MaximizeFull);
+
+        QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->maximizeMode(), MaximizeFull);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeFull);
+        QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+        QCOMPARE(window->moveResizeGeometry(), QRectF(0, 0, 1280, 1024));
+
+        previousMaximizeMode = window->maximizeMode();
+        previousQuickTileMode = window->quickTileMode();
+    };
+
+    auto restore = [&]() {
+        QCOMPARE(window->geometryRestore(), originalGeometry);
+        QCOMPARE(window->quickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->requestedQuickTileMode(), previousQuickTileMode);
+        QCOMPARE(window->maximizeMode(), previousMaximizeMode);
+        QCOMPARE(window->requestedMaximizeMode(), previousMaximizeMode);
+
+        window->maximize(MaximizeRestore);
+
+        QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+        QCOMPARE(window->maximizeMode(), MaximizeRestore);
+        QCOMPARE(window->requestedMaximizeMode(), MaximizeRestore);
+        QCOMPARE(window->frameGeometry(), originalGeometry);
+        QCOMPARE(window->moveResizeGeometry(), originalGeometry);
+
+        previousMaximizeMode = window->maximizeMode();
+        previousQuickTileMode = window->quickTileMode();
+    };
+
+    quickTile();
+    maximize();
+    restore();
+
+    quickTile();
+    maximize();
+    restore();
+
+    quickTile();
+    maximize();
+    quickTile();
+    maximize();
+}
+
 void QuickTilingTest::testScript_data()
 {
     QTest::addColumn<QString>("action");
diff --git a/src/window.cpp b/src/window.cpp
index f10d7f5d423..4f6e2e063e3 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3606,14 +3606,12 @@ QRectF Window::quickTileGeometry(QuickTileMode mode, const QPointF &pos) const
     return workspace()->clientArea(MaximizeArea, this, pos);
 }
 
-void Window::updateQuickTileMode(QuickTileMode newMode)
+void Window::exitQuickTileMode()
 {
-    if ((!m_requestedTile && newMode == QuickTileMode(QuickTileFlag::None)) || m_requestedTile->quickTileMode() == newMode) {
-        return;
+    const auto outputs = workspace()->outputs();
+    for (Output *output : outputs) {
+        workspace()->tileManager(output)->forgetWindow(this, nullptr);
     }
-    m_requestedTile = workspace()->tileManager(output())->quickTile(newMode);
-    doSetQuickTileMode();
-    Q_EMIT requestedTileChanged();
 }
 
 void Window::updateElectricGeometryRestore()
@@ -3923,6 +3921,7 @@ void Window::forgetTile(Tile *tile)
 
     m_requestedTile = nullptr;
     doSetQuickTileMode();
+    Q_EMIT requestedTileChanged();
 }
 
 void Window::setTileCompatibility(Tile *tile)
diff --git a/src/window.h b/src/window.h
index bfb82469c9e..c473a44d28f 100644
--- a/src/window.h
+++ b/src/window.h
@@ -1593,7 +1593,7 @@ protected:
     void updateElectricGeometryRestore();
     QRectF quickTileGeometryRestore() const;
     QRectF quickTileGeometry(QuickTileMode mode, const QPointF &pos) const;
-    void updateQuickTileMode(QuickTileMode newMode);
+    void exitQuickTileMode();
 
     // geometry handling
     void checkOffscreenPosition(QRectF *geom, const QRectF &screenArea);
diff --git a/src/x11window.cpp b/src/x11window.cpp
index a0a41e7dfbf..8f84f84d754 100644
--- a/src/x11window.cpp
+++ b/src/x11window.cpp
@@ -3683,8 +3683,7 @@ void X11Window::configureRequest(int value_mask, qreal rx, qreal ry, qreal rw, q
     // however, the user shall be able to force obedience despite and also disobedience in general
     ignore = rules()->checkIgnoreGeometry(ignore);
     if (!ignore) { // either we're not max'd / q'tiled or the user allowed the client to break that - so break it.
-        updateQuickTileMode(QuickTileFlag::None);
-        Q_EMIT quickTileModeChanged();
+        exitQuickTileMode();
     } else if (!app_noborder && requestedQuickTileMode() == QuickTileMode(QuickTileFlag::None) && (requestedMaximizeMode() == MaximizeVertical || requestedMaximizeMode() == MaximizeHorizontal)) {
         // ignoring can be, because either we do, or the user does explicitly not want it.
         // for partially maximized windows we want to allow configures in the other dimension.
@@ -4195,18 +4194,6 @@ void X11Window::maximize(MaximizeMode mode, const QRectF &restore)
         changeMaximizeRecursion = false;
     }
 
-    // Conditional quick tiling exit points
-    if (quickTileMode() != QuickTileMode(QuickTileFlag::None)) {
-        if (old_mode == MaximizeFull && !clientArea.contains(geometryRestore().center())) {
-            // Not restoring on the same screen
-            // TODO: The following doesn't work for some reason
-            // quick_tile_mode = QuickTileFlag::None; // And exit quick tile mode manually
-        } else if ((old_mode == MaximizeVertical && max_mode == MaximizeRestore) || (old_mode == MaximizeFull && max_mode == MaximizeHorizontal)) {
-            // Modifying geometry of a tiled window
-            updateQuickTileMode(QuickTileFlag::None); // Exit quick tile mode without restoring geometry
-        }
-    }
-
     switch (max_mode) {
 
     case MaximizeVertical: {
@@ -4223,6 +4210,7 @@ void X11Window::maximize(MaximizeMode mode, const QRectF &restore)
         } else {
             moveResize(QRectF(x(), clientArea.top(), width(), clientArea.height()));
         }
+        exitQuickTileMode();
         info->setState(NET::MaxVert, NET::Max);
         break;
     }
@@ -4241,6 +4229,7 @@ void X11Window::maximize(MaximizeMode mode, const QRectF &restore)
         } else {
             moveResize(QRectF(clientArea.left(), y(), clientArea.width(), height()));
         }
+        exitQuickTileMode();
         info->setState(NET::MaxHoriz, NET::Max);
         break;
     }
@@ -4287,15 +4276,13 @@ void X11Window::maximize(MaximizeMode mode, const QRectF &restore)
         }
 
         moveResize(restore);
-
         info->setState(NET::States(), NET::Max);
-        updateQuickTileMode(QuickTileFlag::None);
         break;
     }
 
     case MaximizeFull: {
         moveResize(clientArea);
-        updateQuickTileMode(QuickTileFlag::None);
+        exitQuickTileMode();
         info->setState(NET::Max, NET::Max);
         break;
     }
diff --git a/src/xdgshellwindow.cpp b/src/xdgshellwindow.cpp
index a09760c4a2f..d5dcc109838 100644
--- a/src/xdgshellwindow.cpp
+++ b/src/xdgshellwindow.cpp
@@ -1631,6 +1631,10 @@ void XdgToplevelWindow::maximize(MaximizeMode mode, const QRectF &restore)
         }
     }
 
+    if (m_requestedMaximizeMode != MaximizeRestore) {
+        exitQuickTileMode();
+    }
+
     QRectF geometry = oldGeometry;
 
     if (m_requestedMaximizeMode & MaximizeHorizontal) {
@@ -1669,8 +1673,6 @@ void XdgToplevelWindow::maximize(MaximizeMode mode, const QRectF &restore)
         }
     }
 
-    updateQuickTileMode(QuickTileFlag::None);
-
     moveResize(geometry);
 
     doSetMaximized();
-- 
GitLab


From fb10f3dde35d0f2ab057a73330d9e72fbf7addb0 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Sat, 14 Dec 2024 03:38:21 +0200
Subject: [PATCH 10/32] Resolve conflict between tile managers

When the current desktop changes, every tile manager is going to apply
its tiles to the windows. If a tile manager doesn't manage the given
window, it will assign a null tile to the window anyway, thus potentially
overwriting the tile assigned by another tile manager.
---
 src/tiles/tilemanager.cpp |  5 -----
 src/workspace.cpp         | 15 +++++++++++++++
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index 7809830272c..e8d89166da6 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -96,11 +96,6 @@ TileManager::TileManager(Output *parent)
         m_quickRootTile = m_quickRootTiles[newDesk];
         Q_EMIT rootTileChanged(m_rootTile);
         Q_EMIT modelChanged(m_rootTile->model());
-
-        const QList<Window *> windows = Workspace::self()->windows();
-        for (auto *w : windows) {
-            w->requestTile(tileForWindow(w, newDesk));
-        }
     });
 }
 
diff --git a/src/workspace.cpp b/src/workspace.cpp
--- a/src/workspace.cpp
+++ b/src/workspace.cpp
@@ -1033,5 +1033,20 @@ void Workspace::updateWindowVisibilityAndActivateOnDesktopChange(VirtualDesktop *newDesktop)
     // Restore the focus on this desktop
     --block_focus;
 
+    for (Window *window : std::as_const(m_windows)) {
+        if (!window->isOnDesktop(newDesktop)) {
+            continue;
+        }
+
+        Tile *tile = nullptr;
+        for (const auto &[output, manager] : m_tileManagers) {
+            if (Tile *candidate = manager->tileForWindow(window, newDesktop)) {
+                tile = candidate;
+            }
+        }
+
+        window->requestTile(tile);
+    }
+
     activateWindowOnDesktop(newDesktop);
 }
-- 
GitLab


From b38f1095af75dc9cb365d399e51ea78541738aa2 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Sat, 14 Dec 2024 03:42:30 +0200
Subject: [PATCH 11/32] tiles: Make quick tiling per virtual desktop

This makes quick tiles consistent with custom tiles. Also, if a window
is tiled on another desktop, nothing should happen when the none tile
mode is set.
---
 autotests/integration/quick_tiling_test.cpp | 189 ++++++++++++++++++++
 src/tiles/tile.cpp                          |  20 ---
 src/tiles/tilemanager.h                     |   1 -
 src/window.cpp                              |   2 +-
 4 files changed, 190 insertions(+), 22 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index 6f1a26dd1e1..2e0f15088fa 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -16,6 +16,7 @@
 #include "scripting/scripting.h"
 #include "tiles/tilemanager.h"
 #include "utils/common.h"
+#include "virtualdesktops.h"
 #include "wayland_server.h"
 #include "window.h"
 #include "workspace.h"
@@ -99,6 +100,8 @@ private Q_SLOTS:
     void testMultiScreenX11();
     void testQuickTileAndMaximize();
     void testQuickTileAndMaximizeX11();
+    void testPerDesktop();
+    void testPerDesktopX11();
     void testScript_data();
     void testScript();
     void testDontCrashWithMaximizeWindowRule();
@@ -138,6 +141,8 @@ void QuickTilingTest::init()
 
     workspace()->setActiveOutput(QPoint(640, 512));
     input()->pointer()->warp(QPoint(640, 512));
+    VirtualDesktopManager::self()->setCount(2);
+    VirtualDesktopManager::self()->setCurrent(1);
 }
 
 void QuickTilingTest::cleanup()
@@ -1237,6 +1242,190 @@ void QuickTilingTest::testQuickTileAndMaximizeX11()
     maximize();
 }
 
+void QuickTilingTest::testPerDesktop()
+{
+    // This test verifies that a window can be tiled differently depending on the virtual desktop.
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(tileChangedSpy.wait());
+    };
+
+    // tile the window in the left half of the screen on the first virtual desktop
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Left);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // switch to the second virtual desktop, the window will still remain tiled, although invisible
+    VirtualDesktopManager::self()->setCurrent(2);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    VirtualDesktopManager::self()->setCurrent(1);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+
+    // nothing will happen if the window is untiled on the second virtual desktop
+    VirtualDesktopManager::self()->setCurrent(2);
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+
+    // tile the window in the right half of the screen on the second virtual desktop
+    window->setOnAllDesktops(true);
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Right);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+
+    // when we return back to the first virtual desktop, the window will be tiled in the left half of the screen
+    VirtualDesktopManager::self()->setCurrent(1);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // and if we go back to the second virtual desktop, the window will be tiled in the right half of the screen
+    VirtualDesktopManager::self()->setCurrent(2);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+
+    // untile the window on the second virtual desktop
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
+
+    // go back to the first virtual desktop, the window will be tiled
+    VirtualDesktopManager::self()->setCurrent(1);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // go to the second virtual desktop, the window will be untiled
+    VirtualDesktopManager::self()->setCurrent(2);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
+}
+
+void QuickTilingTest::testPerDesktopX11()
+{
+    // This test verifies that an X11 window can be tiled differently depending on the virtual desktop.
+
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    const QRectF originalGeometry = window->frameGeometry();
+
+    // tile the window in the left half of the screen on the first virtual desktop
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Left);
+    QCOMPARE(tileChangedSpy.count(), 1);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // switch to the second virtual desktop, the window will still remain tiled, although invisible
+    VirtualDesktopManager::self()->setCurrent(2);
+    QCOMPARE(tileChangedSpy.count(), 1);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    VirtualDesktopManager::self()->setCurrent(1);
+    QCOMPARE(tileChangedSpy.count(), 1);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+
+    // nothing will happen if the window is untiled on the second virtual desktop
+    VirtualDesktopManager::self()->setCurrent(2);
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+    QCOMPARE(tileChangedSpy.count(), 1);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+
+    // tile the window in the right half of the screen on the second virtual desktop
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    window->setOnAllDesktops(true);
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Right);
+    QCOMPARE(tileChangedSpy.count(), 2);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+
+    // when we return back to the first virtual desktop, the window will be tiled in the left half of the screen
+    VirtualDesktopManager::self()->setCurrent(1);
+    QCOMPARE(tileChangedSpy.count(), 3);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // and if we go back to the second virtual desktop, the window will be tiled in the right half of the screen
+    VirtualDesktopManager::self()->setCurrent(2);
+    QCOMPARE(tileChangedSpy.count(), 4);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+
+    // untile the window on the second virtual desktop
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+    QCOMPARE(tileChangedSpy.count(), 5);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), originalGeometry);
+
+    // go back to the first virtual desktop, the window will be tiled
+    VirtualDesktopManager::self()->setCurrent(1);
+    QCOMPARE(tileChangedSpy.count(), 6);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // go to the second virtual desktop, the window will be untiled
+    VirtualDesktopManager::self()->setCurrent(2);
+    QCOMPARE(tileChangedSpy.count(), 7);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), originalGeometry);
+}
+
 void QuickTilingTest::testScript_data()
 {
     QTest::addColumn<QString>("action");
diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index cb7260abf9e..81f9a7e2fa7 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -33,24 +33,6 @@ Tile::Tile(TileManager *tiling, Tile *parent)
     }
     connect(Workspace::self(), &Workspace::configChanged, this, &Tile::windowGeometryChanged);
     connect(Workspace::self(), &Workspace::windowRemoved, this, &Tile::removeWindow);
-
-    connect(m_tiling, &TileManager::tileForWindowChanged, this,
-            [this](Window *window, Tile *owner) {
-        // We only care when the owner on another desktop changed
-        // And we only want to synchronize non-custom types of tiles
-        if (owner == this || m_quickTileMode == QuickTileFlag::Custom) {
-            return;
-        }
-
-        // There is a new owner: we want to copy it in this desktop
-        // to have the same quickTileMode
-        if (owner && owner->quickTileMode() == m_quickTileMode) {
-            addWindow(window);
-        } else {
-            // Lost the owner: the "global" QuickTileMode becomes null
-            removeWindow(window);
-        }
-    });
 }
 
 Tile::~Tile()
@@ -397,7 +379,6 @@ bool Tile::addWindow(Window *window)
 
     Q_EMIT windowAdded(window);
     Q_EMIT windowsChanged();
-    Q_EMIT m_tiling->tileForWindowChanged(window, this);
 
     // We can actually manage the window geometry if our desktop is current
     // or if our desktop is the only desktop the window is in
@@ -413,7 +394,6 @@ bool Tile::removeWindow(Window *window)
     if (m_windows.removeOne(window)) {
         Q_EMIT windowRemoved(window);
         Q_EMIT windowsChanged();
-        Q_EMIT m_tiling->tileForWindowChanged(window, nullptr);
 
         if (window->requestedTile() == this) {
             window->requestTile(nullptr);
diff --git a/src/tiles/tilemanager.h b/src/tiles/tilemanager.h
index 9fa6e5075c0..28284abb2ae 100644
--- a/src/tiles/tilemanager.h
+++ b/src/tiles/tilemanager.h
@@ -62,7 +62,6 @@ public:
 
 Q_SIGNALS:
     void tileRemoved(KWin::Tile *tile);
-    void tileForWindowChanged(Window *window, Tile *owner);
     void rootTileChanged(CustomTile *rootTile);
     void modelChanged(TileModel *model);
 
diff --git a/src/window.cpp b/src/window.cpp
index 4f6e2e063e3..4044e1bacc9 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3820,7 +3820,7 @@ void Window::setQuickTileMode(QuickTileMode mode, const QPointF &tileAtPoint)
     if (m_requestedTile != tile) {
         if (tile) {
             tile->addWindow(this);
-        } else if (m_requestedTile) {
+        } else if (m_requestedTile && m_requestedTile->isActive()) {
             m_requestedTile->removeWindow(this);
         }
     }
-- 
GitLab


From f78f155c9c5c787a87de8a11f0a5ad3e243cba2f Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Mon, 16 Dec 2024 17:42:46 +0200
Subject: [PATCH 12/32] Fix custom tiles shortcut

* use tile::addWindow() not Window::requestTile()
* base currentTile upon m_requestedTile
* assign a tile from bestTileForPosition only if we don't already have a tile (or if is not custom)
* add an autotest which excercise those shortcuts
---
 autotests/integration/tiles_test.cpp | 79 ++++++++++++++++++++++++++++
 src/window.cpp                       | 12 ++---
 2 files changed, 85 insertions(+), 6 deletions(-)

diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index 71b9447f98e..f9971887132 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -32,6 +32,7 @@ private Q_SLOTS:
     void testWindowInteraction();
     void testAssignedTileDeletion();
     void resizeTileFromWindow();
+    void shortcuts();
 
 private:
     void createSampleLayout();
@@ -407,6 +408,84 @@ void TilesTest::resizeTileFromWindow()
     QCOMPARE(leftTile->windowGeometry(), QRect(4, 4, 518, 1016));
     QCOMPARE(middleTile->windowGeometry(), QRect(526, 4, 432, 1016));
 }
+
+void TilesTest::shortcuts()
+{
+    // Our tile layout
+    // | | | |
+    // | |-| |
+    // | | | |
+    auto leftTile = qobject_cast<CustomTile *>(m_rootTile->childTiles()[0]);
+    auto centerTile = qobject_cast<CustomTile *>(m_rootTile->childTiles()[1]);
+    auto rightTile = qobject_cast<CustomTile *>(m_rootTile->childTiles()[2]);
+    auto topCenterTile = qobject_cast<CustomTile *>(centerTile->childTiles()[0]);
+    auto bottomCenterTile = qobject_cast<CustomTile *>(centerTile->childTiles()[1]);
+
+    // Create a window, don't tile yet
+    std::unique_ptr<KWayland::Client::Surface> rootSurface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> root(Test::createXdgToplevelSurface(rootSurface.get()));
+
+    auto window = Test::renderAndWaitForShown(rootSurface.get(), QSize(100, 100), Qt::cyan);
+    QVERIFY(window);
+
+    // Trigger the shortcut, window should be tiled now
+    // |w| | |
+    // |w|-| |
+    // |w| | |
+    window->handleCustomQuickTileShortcut(QuickTileFlag::Left);
+    QCOMPARE(window->requestedTile(), leftTile);
+    QVERIFY(leftTile->windows().contains(window));
+
+    // Make the window move around the grid
+    // | |w| |
+    // | |-| |
+    // | | | |
+    window->handleCustomQuickTileShortcut(QuickTileFlag::Right);
+    QCOMPARE(window->requestedTile(), topCenterTile);
+    QVERIFY(!leftTile->windows().contains(window));
+    QVERIFY(topCenterTile->windows().contains(window));
+
+    // | | |w|
+    // | |-|w|
+    // | | |w|
+    window->handleCustomQuickTileShortcut(QuickTileFlag::Right);
+    QCOMPARE(window->requestedTile(), rightTile);
+    QVERIFY(!topCenterTile->windows().contains(window));
+    QVERIFY(rightTile->windows().contains(window));
+
+    // Right doesn't do anything now
+    // | | |w|
+    // | |-|w|
+    // | | |w|
+    window->handleCustomQuickTileShortcut(QuickTileFlag::Right);
+    QCOMPARE(window->requestedTile(), rightTile);
+    QVERIFY(!topCenterTile->windows().contains(window));
+    QVERIFY(rightTile->windows().contains(window));
+
+    // | |w| |
+    // | |-| |
+    // | | | |
+    window->handleCustomQuickTileShortcut(QuickTileFlag::Left);
+    QCOMPARE(window->requestedTile(), topCenterTile);
+    QVERIFY(!rightTile->windows().contains(window));
+    QVERIFY(topCenterTile->windows().contains(window));
+
+    // | | | |
+    // | |-| |
+    // | |w| |
+    window->handleCustomQuickTileShortcut(QuickTileFlag::Bottom);
+    QCOMPARE(window->requestedTile(), bottomCenterTile);
+    QVERIFY(!topCenterTile->windows().contains(window));
+    QVERIFY(bottomCenterTile->windows().contains(window));
+
+    // |w| | |
+    // |w|-| |
+    // |w| | |
+    window->handleCustomQuickTileShortcut(QuickTileFlag::Left);
+    QCOMPARE(window->requestedTile(), leftTile);
+    QVERIFY(!bottomCenterTile->windows().contains(window));
+    QVERIFY(leftTile->windows().contains(window));
+}
 }
 
 WAYLANDTEST_MAIN(KWin::TilesTest)
diff --git a/src/window.cpp b/src/window.cpp
index 4044e1bacc9..3b1395df82a 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3756,15 +3756,15 @@ void Window::handleCustomQuickTileShortcut(QuickTileMode mode)
         return;
     }
     // if window is not tiled already, set it to nearest one
-    const auto currentTile = workspace()->tileManager(workspace()->outputAt(moveResizeGeometry().center()))->bestTileForPosition(moveResizeGeometry().center());
-    if (!currentTile) {
+    Tile *tileAtPoint = workspace()->tileManager(workspace()->outputAt(moveResizeGeometry().center()))->bestTileForPosition(moveResizeGeometry().center());
+    if (!tileAtPoint) {
         return;
     }
-    if (moveResizeGeometry() != currentTile->windowGeometry()) {
-        requestTile(currentTile);
+    if (tileAtPoint != m_requestedTile) {
+        tileAtPoint->addWindow(this);
         return;
     }
-    const auto customTile = qobject_cast<CustomTile *>(currentTile);
+    const auto customTile = qobject_cast<CustomTile *>(tileAtPoint);
     if (!customTile) {
         return;
     }
@@ -3784,7 +3784,7 @@ void Window::handleCustomQuickTileShortcut(QuickTileMode mode)
     }
     CustomTile *next = customTile->nextNonLayoutTileAt(edge);
     if (next) {
-        requestTile(next);
+        next->addWindow(this);
     }
 }
 
-- 
GitLab


From 6c1fccb8ad0174d99501185dd8c917f86035b835 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Wed, 18 Dec 2024 16:39:35 +0200
Subject: [PATCH 13/32] autotests: Test moving window between quick tiles and
 custom tiles

---
 autotests/integration/quick_tiling_test.cpp | 475 ++++++++++++++++++++
 1 file changed, 475 insertions(+)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index 2e0f15088fa..f308886da16 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -102,6 +102,10 @@ private Q_SLOTS:
     void testQuickTileAndMaximizeX11();
     void testPerDesktop();
     void testPerDesktopX11();
+    void testMoveBetweenQuickTileAndCustomTileSameDesktop();
+    void testMoveBetweenQuickTileAndCustomTileSameDesktopX11();
+    void testMoveBetweenQuickTileAndCustomTileCrossDesktops();
+    void testMoveBetweenQuickTileAndCustomTileCrossDesktopsX11();
     void testScript_data();
     void testScript();
     void testDontCrashWithMaximizeWindowRule();
@@ -1426,6 +1430,477 @@ void QuickTilingTest::testPerDesktopX11()
     QCOMPARE(window->frameGeometry(), originalGeometry);
 }
 
+void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileSameDesktop()
+{
+    // This test checks that a window can be moved between quick tiles and custom tiles on the same virtual desktop.
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(tileChangedSpy.wait());
+    };
+
+    const QRectF originalGeometry = window->frameGeometry();
+    const auto outputs = workspace()->outputs();
+    for (Output *first : outputs) {
+        for (Output *second : outputs) {
+            const QPointF customPoint = first->geometry().center();
+            const QPointF quickPoint = second->geometry().center();
+            Tile *customTile = workspace()->tileManager(first)->bestTileForPosition(customPoint);
+            Tile *quickTile = workspace()->tileManager(second)->quickTile(QuickTileFlag::Left);
+
+            window->setQuickTileMode(QuickTileFlag::Left, quickPoint);
+            QCOMPARE(window->tile(), nullptr);
+            QVERIFY(!customTile->windows().contains(window));
+            QCOMPARE(window->requestedTile(), quickTile);
+            QVERIFY(quickTile->windows().contains(window));
+            ackConfigure();
+            QCOMPARE(window->tile(), quickTile);
+            QCOMPARE(window->requestedTile(), quickTile);
+            QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+
+            window->setQuickTileMode(QuickTileFlag::Custom, customPoint);
+            QCOMPARE(window->tile(), quickTile);
+            QVERIFY(!quickTile->windows().contains(window));
+            QCOMPARE(window->requestedTile(), customTile);
+            QVERIFY(customTile->windows().contains(window));
+            ackConfigure();
+            QCOMPARE(window->tile(), customTile);
+            QCOMPARE(window->requestedTile(), customTile);
+            QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+            window->setQuickTileMode(QuickTileFlag::Left, quickPoint);
+            QCOMPARE(window->tile(), customTile);
+            QVERIFY(!customTile->windows().contains(window));
+            QCOMPARE(window->requestedTile(), quickTile);
+            QVERIFY(quickTile->windows().contains(window));
+            ackConfigure();
+            QCOMPARE(window->tile(), quickTile);
+            QCOMPARE(window->requestedTile(), quickTile);
+            QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+
+            window->setQuickTileMode(QuickTileFlag::Custom, customPoint);
+            QCOMPARE(window->tile(), quickTile);
+            QVERIFY(!quickTile->windows().contains(window));
+            QCOMPARE(window->requestedTile(), customTile);
+            QVERIFY(customTile->windows().contains(window));
+            ackConfigure();
+            QCOMPARE(window->tile(), customTile);
+            QCOMPARE(window->requestedTile(), customTile);
+            QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+            window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+            QCOMPARE(window->tile(), customTile);
+            QVERIFY(!customTile->windows().contains(window));
+            QCOMPARE(window->requestedTile(), nullptr);
+            QVERIFY(!quickTile->windows().contains(window));
+            ackConfigure();
+            QCOMPARE(window->tile(), nullptr);
+            QCOMPARE(window->requestedTile(), nullptr);
+            QCOMPARE(window->frameGeometry(), originalGeometry);
+        }
+    }
+}
+
+void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileSameDesktopX11()
+{
+    // This test checks that an X11 window can be moved between quick tiles and custom tiles on the same virtual desktop.
+
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    const QRectF originalGeometry = window->frameGeometry();
+
+    const auto outputs = workspace()->outputs();
+    for (Output *first : outputs) {
+        for (Output *second : outputs) {
+            const QPointF customPoint = first->geometry().center();
+            const QPointF quickPoint = second->geometry().center();
+            Tile *customTile = workspace()->tileManager(first)->bestTileForPosition(customPoint);
+            Tile *quickTile = workspace()->tileManager(second)->quickTile(QuickTileFlag::Left);
+
+            {
+                QCOMPARE(window->tile(), nullptr);
+                QCOMPARE(window->requestedTile(), nullptr);
+                QVERIFY(!customTile->windows().contains(window));
+                QVERIFY(!quickTile->windows().contains(window));
+
+                window->setQuickTileMode(QuickTileFlag::Left, quickPoint);
+
+                QCOMPARE(window->tile(), quickTile);
+                QCOMPARE(window->requestedTile(), quickTile);
+                QVERIFY(!customTile->windows().contains(window));
+                QVERIFY(quickTile->windows().contains(window));
+                QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+            }
+
+            {
+                QCOMPARE(window->tile(), quickTile);
+                QCOMPARE(window->requestedTile(), quickTile);
+                QVERIFY(!customTile->windows().contains(window));
+                QVERIFY(quickTile->windows().contains(window));
+
+                window->setQuickTileMode(QuickTileFlag::Custom, customPoint);
+
+                QCOMPARE(window->tile(), customTile);
+                QCOMPARE(window->requestedTile(), customTile);
+                QVERIFY(customTile->windows().contains(window));
+                QVERIFY(!quickTile->windows().contains(window));
+                QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+            }
+
+            {
+                QCOMPARE(window->tile(), customTile);
+                QCOMPARE(window->requestedTile(), customTile);
+                QVERIFY(customTile->windows().contains(window));
+                QVERIFY(!quickTile->windows().contains(window));
+
+                window->setQuickTileMode(QuickTileFlag::Left, quickPoint);
+
+                QCOMPARE(window->tile(), quickTile);
+                QCOMPARE(window->requestedTile(), quickTile);
+                QVERIFY(!customTile->windows().contains(window));
+                QVERIFY(quickTile->windows().contains(window));
+                QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+            }
+
+            {
+                QCOMPARE(window->tile(), quickTile);
+                QCOMPARE(window->requestedTile(), quickTile);
+                QVERIFY(!customTile->windows().contains(window));
+                QVERIFY(quickTile->windows().contains(window));
+
+                window->setQuickTileMode(QuickTileFlag::Custom, customPoint);
+
+                QCOMPARE(window->tile(), customTile);
+                QCOMPARE(window->requestedTile(), customTile);
+                QVERIFY(customTile->windows().contains(window));
+                QVERIFY(!quickTile->windows().contains(window));
+                QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+            }
+
+            {
+                QCOMPARE(window->tile(), customTile);
+                QCOMPARE(window->requestedTile(), customTile);
+                QVERIFY(customTile->windows().contains(window));
+                QVERIFY(!quickTile->windows().contains(window));
+
+                window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+
+                QCOMPARE(window->tile(), nullptr);
+                QCOMPARE(window->requestedTile(), nullptr);
+                QVERIFY(!customTile->windows().contains(window));
+                QVERIFY(!quickTile->windows().contains(window));
+                QCOMPARE(window->frameGeometry(), originalGeometry);
+            }
+        }
+    }
+}
+
+void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileCrossDesktops()
+{
+    auto vds = VirtualDesktopManager::self();
+    const auto desktops = vds->desktops();
+    const auto outputs = workspace()->outputs();
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+    window->setOnAllDesktops(true);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(tileChangedSpy.wait());
+    };
+
+    auto applyTileLayout = [](CustomTile *tile, qreal left, qreal right) {
+        const auto previousKiddos = tile->childTiles();
+        for (Tile *kiddo : previousKiddos) {
+            tile->destroyChild(kiddo);
+        }
+
+        tile->split(Tile::LayoutDirection::Horizontal);
+        tile->childTiles().at(0)->setRelativeGeometry(QRectF(0, 0, left, 1.0));
+
+        QCOMPARE(tile->childTiles().at(0)->relativeGeometry(), QRectF(0, 0, left, 1));
+        QCOMPARE(tile->childTiles().at(1)->relativeGeometry(), QRectF(left, 0, right, 1));
+    };
+    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(0)), 0.4, 0.6);
+    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(1)), 0.35, 0.65);
+    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(0)), 0.3, 0.7);
+    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(1)), 0.25, 0.75);
+
+    const QRectF originalGeometry = window->frameGeometry();
+    for (VirtualDesktop *customTileDesktop : desktops) {
+        for (VirtualDesktop *quickTileDesktop : desktops) {
+            if (customTileDesktop == quickTileDesktop) {
+                continue;
+            }
+
+            for (Output *customTileOutput : outputs) {
+                for (Output *quickTileOutput : outputs) {
+                    Tile *quickTile = workspace()->tileManager(quickTileOutput)->quickRootTile(quickTileDesktop)->tileForMode(QuickTileFlag::Left);
+                    Tile *customTile = workspace()->tileManager(customTileOutput)->rootTile(customTileDesktop)->childTile(1);
+
+                    // put the window in a custom tile on the first virtual desktop
+                    vds->setCurrent(customTileDesktop);
+                    customTile->addWindow(window);
+                    QCOMPARE(window->tile(), nullptr);
+                    QCOMPARE(window->requestedTile(), customTile);
+                    QCOMPARE(window->frameGeometry(), originalGeometry);
+                    ackConfigure();
+                    QCOMPARE(window->tile(), customTile);
+                    QCOMPARE(window->requestedTile(), customTile);
+                    QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+                    // switch to the second virtual desktop, the window will be untiled
+                    vds->setCurrent(quickTileDesktop);
+                    QCOMPARE(window->tile(), customTile);
+                    QCOMPARE(window->requestedTile(), nullptr);
+                    QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+                    ackConfigure();
+                    QCOMPARE(window->tile(), nullptr);
+                    QCOMPARE(window->requestedTile(), nullptr);
+                    QCOMPARE(window->frameGeometry(), originalGeometry);
+
+                    // put the window in a quick tile on the second virtual desktop
+                    quickTile->addWindow(window);
+                    QCOMPARE(window->tile(), nullptr);
+                    QCOMPARE(window->requestedTile(), quickTile);
+                    QCOMPARE(window->frameGeometry(), originalGeometry);
+                    ackConfigure();
+                    QCOMPARE(window->tile(), quickTile);
+                    QCOMPARE(window->requestedTile(), quickTile);
+                    QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+
+                    // switch to the first virtual desktop
+                    vds->setCurrent(customTileDesktop);
+                    QCOMPARE(window->tile(), quickTile);
+                    QCOMPARE(window->requestedTile(), customTile);
+                    QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+                    ackConfigure();
+                    QCOMPARE(window->tile(), customTile);
+                    QCOMPARE(window->requestedTile(), customTile);
+                    QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+                    // switch to the second virtual desktop
+                    vds->setCurrent(quickTileDesktop);
+                    QCOMPARE(window->tile(), customTile);
+                    QCOMPARE(window->requestedTile(), quickTile);
+                    QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+                    ackConfigure();
+                    QCOMPARE(window->tile(), quickTile);
+                    QCOMPARE(window->requestedTile(), quickTile);
+                    QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+
+                    // remove the window from the quick tile on the second virtual desktop
+                    quickTile->removeWindow(window);
+                    QCOMPARE(window->tile(), quickTile);
+                    QCOMPARE(window->requestedTile(), nullptr);
+                    QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+                    ackConfigure();
+                    QCOMPARE(window->tile(), nullptr);
+                    QCOMPARE(window->requestedTile(), nullptr);
+                    QCOMPARE(window->frameGeometry(), originalGeometry);
+
+                    // switch to the first virtual desktop
+                    vds->setCurrent(customTileDesktop);
+                    QCOMPARE(window->tile(), nullptr);
+                    QCOMPARE(window->requestedTile(), customTile);
+                    QCOMPARE(window->frameGeometry(), originalGeometry);
+                    ackConfigure();
+                    QCOMPARE(window->tile(), customTile);
+                    QCOMPARE(window->requestedTile(), customTile);
+                    QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+                    // remove the window from the custom tile on the first virtual desktop
+                    customTile->removeWindow(window);
+                    QCOMPARE(window->tile(), customTile);
+                    QCOMPARE(window->requestedTile(), nullptr);
+                    QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+                    ackConfigure();
+                    QCOMPARE(window->tile(), nullptr);
+                    QCOMPARE(window->requestedTile(), nullptr);
+                    QCOMPARE(window->frameGeometry(), originalGeometry);
+                }
+            }
+        }
+    }
+}
+
+void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileCrossDesktopsX11()
+{
+    auto vds = VirtualDesktopManager::self();
+    const auto desktops = vds->desktops();
+    const auto outputs = workspace()->outputs();
+
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+    window->setOnAllDesktops(true);
+
+    auto applyTileLayout = [](CustomTile *tile, qreal left, qreal right) {
+        const auto previousKiddos = tile->childTiles();
+        for (Tile *kiddo : previousKiddos) {
+            tile->destroyChild(kiddo);
+        }
+
+        tile->split(Tile::LayoutDirection::Horizontal);
+        tile->childTiles().at(0)->setRelativeGeometry(QRectF(0, 0, left, 1.0));
+
+        QCOMPARE(tile->childTiles().at(0)->relativeGeometry(), QRectF(0, 0, left, 1));
+        QCOMPARE(tile->childTiles().at(1)->relativeGeometry(), QRectF(left, 0, right, 1));
+    };
+    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(0)), 0.4, 0.6);
+    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(1)), 0.35, 0.65);
+    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(0)), 0.3, 0.7);
+    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(1)), 0.25, 0.75);
+
+    const QRectF originalGeometry = window->frameGeometry();
+    for (VirtualDesktop *customTileDesktop : desktops) {
+        for (VirtualDesktop *quickTileDesktop : desktops) {
+            if (customTileDesktop == quickTileDesktop) {
+                continue;
+            }
+
+            for (Output *customTileOutput : outputs) {
+                for (Output *quickTileOutput : outputs) {
+                    Tile *quickTile = workspace()->tileManager(quickTileOutput)->quickRootTile(quickTileDesktop)->tileForMode(QuickTileFlag::Left);
+                    Tile *customTile = workspace()->tileManager(customTileOutput)->rootTile(customTileDesktop)->childTile(1);
+
+                    // put the window in a custom tile on the first virtual desktop
+                    {
+                        vds->setCurrent(customTileDesktop);
+                        QCOMPARE(window->tile(), nullptr);
+                        QCOMPARE(window->requestedTile(), nullptr);
+                        QCOMPARE(window->frameGeometry(), originalGeometry);
+
+                        customTile->addWindow(window);
+
+                        QCOMPARE(window->tile(), customTile);
+                        QCOMPARE(window->requestedTile(), customTile);
+                        QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+                    }
+
+                    // switch to the second virtual desktop, the window will be untiled
+                    {
+                        QCOMPARE(window->tile(), customTile);
+                        QCOMPARE(window->requestedTile(), customTile);
+                        QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+                        vds->setCurrent(quickTileDesktop);
+
+                        QCOMPARE(window->tile(), nullptr);
+                        QCOMPARE(window->requestedTile(), nullptr);
+                        QCOMPARE(window->frameGeometry(), originalGeometry);
+                    }
+
+                    // put the window in a quick tile on the second virtual desktop
+                    {
+                        QCOMPARE(window->tile(), nullptr);
+                        QCOMPARE(window->requestedTile(), nullptr);
+                        QCOMPARE(window->frameGeometry(), originalGeometry);
+
+                        quickTile->addWindow(window);
+
+                        QCOMPARE(window->tile(), quickTile);
+                        QCOMPARE(window->requestedTile(), quickTile);
+                        QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+                    }
+
+                    // switch to the first virtual desktop
+                    {
+                        QCOMPARE(window->tile(), quickTile);
+                        QCOMPARE(window->requestedTile(), quickTile);
+                        QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+
+                        vds->setCurrent(customTileDesktop);
+
+                        QCOMPARE(window->tile(), customTile);
+                        QCOMPARE(window->requestedTile(), customTile);
+                        QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+                    }
+
+                    // switch to the second virtual desktop
+                    {
+                        QCOMPARE(window->tile(), customTile);
+                        QCOMPARE(window->requestedTile(), customTile);
+                        QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+                        vds->setCurrent(quickTileDesktop);
+
+                        QCOMPARE(window->tile(), quickTile);
+                        QCOMPARE(window->requestedTile(), quickTile);
+                        QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+                    }
+
+                    // remove the window from the quick tile on the second virtual desktop
+                    {
+                        QCOMPARE(window->tile(), quickTile);
+                        QCOMPARE(window->requestedTile(), quickTile);
+                        QCOMPARE(window->frameGeometry(), quickTile->windowGeometry());
+
+                        quickTile->removeWindow(window);
+
+                        QCOMPARE(window->tile(), nullptr);
+                        QCOMPARE(window->requestedTile(), nullptr);
+                        QCOMPARE(window->frameGeometry(), originalGeometry);
+                    }
+
+                    // switch to the first virtual desktop
+                    {
+                        QCOMPARE(window->tile(), nullptr);
+                        QCOMPARE(window->requestedTile(), nullptr);
+                        QCOMPARE(window->frameGeometry(), originalGeometry);
+
+                        vds->setCurrent(customTileDesktop);
+
+                        QCOMPARE(window->tile(), customTile);
+                        QCOMPARE(window->requestedTile(), customTile);
+                        QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+                    }
+
+                    // remove the window from the custom tile on the first virtual desktop
+                    {
+                        QCOMPARE(window->tile(), customTile);
+                        QCOMPARE(window->requestedTile(), customTile);
+                        QCOMPARE(window->frameGeometry(), customTile->windowGeometry());
+
+                        customTile->removeWindow(window);
+
+                        QCOMPARE(window->tile(), nullptr);
+                        QCOMPARE(window->requestedTile(), nullptr);
+                        QCOMPARE(window->frameGeometry(), originalGeometry);
+                    }
+                }
+            }
+        }
+    }
+}
+
 void QuickTilingTest::testScript_data()
 {
     QTest::addColumn<QString>("action");
-- 
GitLab


From 19fc3ffa96b698bf914e456a11f5f1f1ff7908f2 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 13:42:17 +0200
Subject: [PATCH 14/32] Query window geometry from the next tile in
 Window::ensureSpecialStateGeometry()

Given that we already know the next tile, there is no need to go through
the tile tree again. It's okay to ignore the geometry argument because
the window must match the tile geometry. If the window needs to be in a
different place, it must be either untiled or put in another tile.
---
 src/window.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/window.cpp b/src/window.cpp
index 3b1395df82a..927f5f32ef9 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3988,8 +3988,8 @@ QRectF Window::ensureSpecialStateGeometry(const QRectF &geometry)
             ret.setHeight(maximizeArea.height());
         }
         return keepInArea(ret, maximizeArea, false);
-    } else if (requestedQuickTileMode() != QuickTileMode(QuickTileFlag::None)) {
-        return quickTileGeometry(requestedQuickTileMode(), geometry.center());
+    } else if (requestedTile()) {
+        return requestedTile()->windowGeometry();
     } else {
         return geometry;
     }
-- 
GitLab


From 03308ea6c859864305838833363e0856ce257aad Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 16:23:14 +0200
Subject: [PATCH 15/32] autotests: Test switching between quick tiled and
 fullscreen state

---
 autotests/integration/quick_tiling_test.cpp | 156 ++++++++++++++++++++
 src/tiles/tile.cpp                          |   2 +-
 src/window.cpp                              |   5 -
 3 files changed, 157 insertions(+), 6 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index f308886da16..f4e1babeea8 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -100,6 +100,8 @@ private Q_SLOTS:
     void testMultiScreenX11();
     void testQuickTileAndMaximize();
     void testQuickTileAndMaximizeX11();
+    void testQuickTileAndFullScreen();
+    void testQuickTileAndFullScreenX11();
     void testPerDesktop();
     void testPerDesktopX11();
     void testMoveBetweenQuickTileAndCustomTileSameDesktop();
@@ -1246,6 +1248,160 @@ void QuickTilingTest::testQuickTileAndMaximizeX11()
     maximize();
 }
 
+void QuickTilingTest::testQuickTileAndFullScreen()
+{
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy frameGeometryChangedSpy(window, &Window::frameGeometryChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(frameGeometryChangedSpy.wait());
+    };
+
+    // tile the window in the left half of the screen on the first virtual desktop
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Left);
+    QCOMPARE(window->geometryRestore(), QRectF(0, 0, 100, 100));
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // make the window fullscreen
+    window->setFullScreen(true);
+    QCOMPARE(window->fullscreenGeometryRestore(), QRectF(0, 0, 640, 1024));
+    QCOMPARE(window->isFullScreen(), false);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->geometryRestore(), QRectF(0, 0, 100, 100));
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    ackConfigure();
+    QCOMPARE(window->isFullScreen(), true);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+
+    // leave fullscreen mode
+    window->setFullScreen(false);
+    QCOMPARE(window->isFullScreen(), true);
+    QCOMPARE(window->isRequestedFullScreen(), false);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    ackConfigure();
+    QCOMPARE(window->isFullScreen(), false);
+    QCOMPARE(window->isRequestedFullScreen(), false);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // untile the window
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+    QCOMPARE(window->isFullScreen(), false);
+    QCOMPARE(window->isRequestedFullScreen(), false);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    ackConfigure();
+    QCOMPARE(window->isFullScreen(), false);
+    QCOMPARE(window->isRequestedFullScreen(), false);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
+
+    // make the window fullscreen
+    window->setFullScreen(true);
+    QCOMPARE(window->fullscreenGeometryRestore(), QRectF(0, 0, 100, 100));
+    QCOMPARE(window->isFullScreen(), false);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    ackConfigure();
+    QCOMPARE(window->isFullScreen(), true);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+
+    // attempt to tile the window
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Left);
+    QCOMPARE(window->isFullScreen(), true);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+}
+
+void QuickTilingTest::testQuickTileAndFullScreenX11()
+{
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+
+    const QRectF originalGeometry = window->frameGeometry();
+
+    // tile the window in the left half of the screen on the first virtual desktop
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Left);
+    QCOMPARE(window->geometryRestore(), originalGeometry);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // make the window fullscreen
+    window->setFullScreen(true);
+    QCOMPARE(window->fullscreenGeometryRestore(), QRectF(0, 0, 640, 1024));
+    QCOMPARE(window->isFullScreen(), true);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+
+    // leave fullscreen mode
+    window->setFullScreen(false);
+    QCOMPARE(window->isFullScreen(), false);
+    QCOMPARE(window->isRequestedFullScreen(), false);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Left);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 640, 1024));
+
+    // untile the window
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::None);
+    QCOMPARE(window->isFullScreen(), false);
+    QCOMPARE(window->isRequestedFullScreen(), false);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), originalGeometry);
+
+    // make the window fullscreen
+    window->setFullScreen(true);
+    QCOMPARE(window->fullscreenGeometryRestore(), originalGeometry);
+    QCOMPARE(window->isFullScreen(), true);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+
+    // attempt to tile the window
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Left);
+    QCOMPARE(window->isFullScreen(), true);
+    QCOMPARE(window->isRequestedFullScreen(), true);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+}
+
 void QuickTilingTest::testPerDesktop()
 {
     // This test verifies that a window can be tiled differently depending on the virtual desktop.
diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index 81f9a7e2fa7..0975c9dda10 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -342,7 +342,7 @@ void Tile::resizeByPixels(qreal delta, Qt::Edge edge)
 
 bool Tile::addWindow(Window *window)
 {
-    if (!window->isClient()) {
+    if (!window->isResizable() || window->isAppletPopup()) {
         return false;
     }
 
diff --git a/src/window.cpp b/src/window.cpp
index 927f5f32ef9..15fa67a0aac 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3795,11 +3795,6 @@ void Window::setQuickTileModeAtCurrentPosition(QuickTileMode mode)
 
 void Window::setQuickTileMode(QuickTileMode mode, const QPointF &tileAtPoint)
 {
-    // Only allow quick tile on a regular window.
-    if (!isResizable() || isAppletPopup()) {
-        return;
-    }
-
     workspace()->updateFocusMousePosition(Cursors::self()->mouse()->pos()); // may cause leave event
 
     // sanitize the mode, ie. simplify "invalid" combinations
-- 
GitLab


From de2334a4a5029d4b92158be9c1ef810da4dbc9e9 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 17:21:36 +0200
Subject: [PATCH 16/32] tiles: Expose root tile's model property to scripting

This prepares scripting tiling api for deprecating the TileManager.
---
 src/tiles/customtile.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/tiles/customtile.h b/src/tiles/customtile.h
index 5f7c523f583..d05a2bd2205 100644
--- a/src/tiles/customtile.h
+++ b/src/tiles/customtile.h
@@ -61,6 +61,8 @@ private:
 class RootTile : public CustomTile
 {
     Q_OBJECT
+    Q_PROPERTY(KWin::TileModel *model READ model CONSTANT)
+
 public:
     RootTile(TileManager *tiling, VirtualDesktop *desktop);
 
-- 
GitLab


From 018aff29a11deebc96543feff634620b7b6fd897 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 17:25:13 +0200
Subject: [PATCH 17/32] tiles: Add helper functions in RootTile to pick leaf
 tile nodes

This prepares scripting tiling api for deprecating the TileManager.
---
 src/tiles/customtile.cpp  | 30 ++++++++++++++++++++++++++++++
 src/tiles/customtile.h    |  3 +++
 src/tiles/tilemanager.cpp | 22 +---------------------
 3 files changed, 34 insertions(+), 21 deletions(-)

diff --git a/src/tiles/customtile.cpp b/src/tiles/customtile.cpp
index 71c18c03560..c3524b9863f 100644
--- a/src/tiles/customtile.cpp
+++ b/src/tiles/customtile.cpp
@@ -456,6 +456,36 @@ TileModel *RootTile::model() const
     return m_tileModel.get();
 }
 
+Tile *RootTile::pick(const QPointF &point) const
+{
+    const auto tiles = descendants();
+    qreal minimumDistance = std::numeric_limits<qreal>::max();
+    Tile *ret = nullptr;
+
+    for (auto *t : tiles) {
+        if (!t->isLayout()) {
+            const auto r = t->absoluteGeometry();
+            // It's possible for tiles to overlap, so take the one which center is nearer to mouse pos
+            qreal distance = (r.center() - point).manhattanLength();
+            if (!exclusiveContains(r, point)) {
+                // This gives a strong preference for tiles that contain the point
+                // still base on distance though as floating tiles can overlap
+                distance += m_tiling->output()->geometryF().width();
+            }
+            if (distance < minimumDistance) {
+                minimumDistance = distance;
+                ret = t;
+            }
+        }
+    }
+    return ret;
+}
+
+Tile *RootTile::pick(qreal x, qreal y) const
+{
+    return pick(QPointF(x, y));
+}
+
 } // namespace KWin
 
 #include "moc_customtile.cpp"
diff --git a/src/tiles/customtile.h b/src/tiles/customtile.h
index d05a2bd2205..fe982cea4d7 100644
--- a/src/tiles/customtile.h
+++ b/src/tiles/customtile.h
@@ -70,6 +70,9 @@ public:
 
     TileModel *model() const;
 
+    Q_INVOKABLE KWin::Tile *pick(const QPointF &point) const;
+    Q_INVOKABLE KWin::Tile *pick(qreal x, qreal y) const;
+
 private:
     std::unique_ptr<TileModel> m_tileModel = nullptr;
 };
diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index e8d89166da6..ef742f3528e 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -116,27 +116,7 @@ Output *TileManager::output() const
 
 Tile *TileManager::bestTileForPosition(const QPointF &pos)
 {
-    const auto tiles = m_rootTile->descendants();
-    qreal minimumDistance = std::numeric_limits<qreal>::max();
-    Tile *ret = nullptr;
-
-    for (auto *t : tiles) {
-        if (!t->isLayout()) {
-            const auto r = t->absoluteGeometry();
-            // It's possible for tiles to overlap, so take the one which center is nearer to mouse pos
-            qreal distance = (r.center() - pos).manhattanLength();
-            if (!exclusiveContains(r, pos)) {
-                // This gives a strong preference for tiles that contain the point
-                // still base on distance though as floating tiles can overlap
-                distance += m_output->geometryF().width();
-            }
-            if (distance < minimumDistance) {
-                minimumDistance = distance;
-                ret = t;
-            }
-        }
-    }
-    return ret;
+    return m_rootTile->pick(pos);
 }
 
 Tile *TileManager::bestTileForPosition(qreal x, qreal y)
-- 
GitLab


From c8173cf48bc628429178accaa41436cd2abd162c Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 17:42:05 +0200
Subject: [PATCH 18/32] Introduce Workspace::rootTile()

The rootTile() function provides a convenient way to get the root tile
for the given desktop and output.
---
 autotests/integration/outputchanges_test.cpp |  4 ++--
 autotests/integration/quick_tiling_test.cpp  | 20 ++++++++++----------
 autotests/integration/tiles_test.cpp         |  2 +-
 src/tiles/tilemanager.cpp                    |  4 ++--
 src/tiles/tilemanager.h                      |  4 ++--
 src/workspace.cpp                            | 15 ++++++++++++++-
 src/workspace.h                              | 13 ++++++++++++-
 7 files changed, 43 insertions(+), 19 deletions(-)

diff --git a/autotests/integration/outputchanges_test.cpp b/autotests/integration/outputchanges_test.cpp
index 45362d29298..8ab4cb461c7 100644
--- a/autotests/integration/outputchanges_test.cpp
+++ b/autotests/integration/outputchanges_test.cpp
@@ -720,7 +720,7 @@ void OutputChangesTest::testQuickTileUntileWindowRestoredAfterEnablingOutput()
 void OutputChangesTest::testCustomTiledWindowRestoredAfterEnablingOutput_data()
 {
     const auto outputs = kwinApp()->outputBackend()->outputs();
-    const size_t tileCount = workspace()->tileManager(outputs[1])->rootTile()->childTiles().size();
+    const size_t tileCount = workspace()->rootTile(outputs[1])->childTiles().size();
 
     QTest::addColumn<size_t>("tileIndex");
     for (size_t i = 0; i < tileCount; i++) {
@@ -765,7 +765,7 @@ void OutputChangesTest::testCustomTiledWindowRestoredAfterEnablingOutput()
     }
 
     QFETCH(size_t, tileIndex);
-    const QRectF customTileGeom = workspace()->tileManager(outputs[1])->rootTile()->childTiles()[tileIndex]->windowGeometry();
+    const QRectF customTileGeom = workspace()->rootTile(outputs[1])->childTiles()[tileIndex]->windowGeometry();
 
     // Move the window to the right monitor and put it in the middle tile.
     QSignalSpy frameGeometryChangedSpy(window, &Window::frameGeometryChanged);
diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index f4e1babeea8..5e2194c3038 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -1804,10 +1804,10 @@ void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileCrossDesktops()
         QCOMPARE(tile->childTiles().at(0)->relativeGeometry(), QRectF(0, 0, left, 1));
         QCOMPARE(tile->childTiles().at(1)->relativeGeometry(), QRectF(left, 0, right, 1));
     };
-    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(0)), 0.4, 0.6);
-    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(1)), 0.35, 0.65);
-    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(0)), 0.3, 0.7);
-    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(1)), 0.25, 0.75);
+    applyTileLayout(workspace()->rootTile(outputs.at(0), desktops.at(0)), 0.4, 0.6);
+    applyTileLayout(workspace()->rootTile(outputs.at(0), desktops.at(1)), 0.35, 0.65);
+    applyTileLayout(workspace()->rootTile(outputs.at(1), desktops.at(0)), 0.3, 0.7);
+    applyTileLayout(workspace()->rootTile(outputs.at(1), desktops.at(1)), 0.25, 0.75);
 
     const QRectF originalGeometry = window->frameGeometry();
     for (VirtualDesktop *customTileDesktop : desktops) {
@@ -1819,7 +1819,7 @@ void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileCrossDesktops()
             for (Output *customTileOutput : outputs) {
                 for (Output *quickTileOutput : outputs) {
                     Tile *quickTile = workspace()->tileManager(quickTileOutput)->quickRootTile(quickTileDesktop)->tileForMode(QuickTileFlag::Left);
-                    Tile *customTile = workspace()->tileManager(customTileOutput)->rootTile(customTileDesktop)->childTile(1);
+                    Tile *customTile = workspace()->rootTile(customTileOutput, customTileDesktop)->childTile(1);
 
                     // put the window in a custom tile on the first virtual desktop
                     vds->setCurrent(customTileDesktop);
@@ -1930,10 +1930,10 @@ void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileCrossDesktopsX11()
         QCOMPARE(tile->childTiles().at(0)->relativeGeometry(), QRectF(0, 0, left, 1));
         QCOMPARE(tile->childTiles().at(1)->relativeGeometry(), QRectF(left, 0, right, 1));
     };
-    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(0)), 0.4, 0.6);
-    applyTileLayout(workspace()->tileManager(outputs.at(0))->rootTile(desktops.at(1)), 0.35, 0.65);
-    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(0)), 0.3, 0.7);
-    applyTileLayout(workspace()->tileManager(outputs.at(1))->rootTile(desktops.at(1)), 0.25, 0.75);
+    applyTileLayout(workspace()->rootTile(outputs.at(0), desktops.at(0)), 0.4, 0.6);
+    applyTileLayout(workspace()->rootTile(outputs.at(0), desktops.at(1)), 0.35, 0.65);
+    applyTileLayout(workspace()->rootTile(outputs.at(1), desktops.at(0)), 0.3, 0.7);
+    applyTileLayout(workspace()->rootTile(outputs.at(1), desktops.at(1)), 0.25, 0.75);
 
     const QRectF originalGeometry = window->frameGeometry();
     for (VirtualDesktop *customTileDesktop : desktops) {
@@ -1945,7 +1945,7 @@ void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileCrossDesktopsX11()
             for (Output *customTileOutput : outputs) {
                 for (Output *quickTileOutput : outputs) {
                     Tile *quickTile = workspace()->tileManager(quickTileOutput)->quickRootTile(quickTileDesktop)->tileForMode(QuickTileFlag::Left);
-                    Tile *customTile = workspace()->tileManager(customTileOutput)->rootTile(customTileDesktop)->childTile(1);
+                    Tile *customTile = workspace()->rootTile(customTileOutput, customTileDesktop)->childTile(1);
 
                     // put the window in a custom tile on the first virtual desktop
                     {
diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index f9971887132..f2ba18860c1 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -67,7 +67,7 @@ void TilesTest::init()
     input()->pointer()->warp(QPoint(640, 512));
     m_output = workspace()->activeOutput();
     m_tileManager = workspace()->tileManager(m_output);
-    m_rootTile = m_tileManager->rootTile();
+    m_rootTile = workspace()->rootTile(m_output);
     QAbstractItemModelTester(m_tileManager->model(), QAbstractItemModelTester::FailureReportingMode::QtTest);
     while (m_rootTile->childCount() > 0) {
         static_cast<CustomTile *>(m_rootTile->childTile(0))->remove();
diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index ef742f3528e..6b178e4815b 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -124,12 +124,12 @@ Tile *TileManager::bestTileForPosition(qreal x, qreal y)
     return bestTileForPosition({x, y});
 }
 
-CustomTile *TileManager::rootTile(VirtualDesktop *desktop) const
+RootTile *TileManager::rootTile(VirtualDesktop *desktop) const
 {
     return m_rootTiles.value(desktop);
 }
 
-CustomTile *TileManager::rootTile() const
+RootTile *TileManager::rootTile() const
 {
     return m_rootTile;
 }
diff --git a/src/tiles/tilemanager.h b/src/tiles/tilemanager.h
index 28284abb2ae..df2b6786daf 100644
--- a/src/tiles/tilemanager.h
+++ b/src/tiles/tilemanager.h
@@ -50,8 +50,8 @@ public:
 
     KWin::Tile *bestTileForPosition(const QPointF &pos);
     Q_INVOKABLE KWin::Tile *bestTileForPosition(qreal x, qreal y); // For scripting
-    CustomTile *rootTile(VirtualDesktop *desktop) const;
-    CustomTile *rootTile() const;
+    RootTile *rootTile(VirtualDesktop *desktop) const;
+    RootTile *rootTile() const;
     QuickRootTile *quickRootTile(VirtualDesktop *desktop) const;
     KWin::Tile *quickTile(QuickTileMode mode) const;
 
diff --git a/src/workspace.cpp b/src/workspace.cpp
index f867b4bef47..a413939a448 100644
--- a/src/workspace.cpp
+++ b/src/workspace.cpp
@@ -3034,7 +3034,7 @@ ScreenEdges *Workspace::screenEdges() const
     return m_screenEdges.get();
 }
 
-TileManager *Workspace::tileManager(Output *output)
+TileManager *Workspace::tileManager(Output *output) const
 {
     if (auto search = m_tileManagers.find(output); search != m_tileManagers.end()) {
         return search->second.get();
@@ -3043,6 +3043,19 @@ TileManager *Workspace::tileManager(Output *output)
     }
 }
 
+RootTile *Workspace::rootTile(Output *output) const
+{
+    return rootTile(output, VirtualDesktopManager::self()->currentDesktop());
+}
+
+RootTile *Workspace::rootTile(Output *output, VirtualDesktop *desktop) const
+{
+    if (auto manager = tileManager(output)) {
+        return manager->rootTile(desktop);
+    }
+    return nullptr;
+}
+
 #if KWIN_BUILD_TABBOX
 TabBox::TabBox *Workspace::tabbox() const
 {
diff --git a/src/workspace.h b/src/workspace.h
index 3348db10b13..828816ddc12 100644
--- a/src/workspace.h
+++ b/src/workspace.h
@@ -77,6 +77,7 @@ class PlaceholderInputEventFilter;
 class PlaceholderOutput;
 class Placement;
 class OutputConfiguration;
+class RootTile;
 class TileManager;
 class OutputConfigurationStore;
 class LidSwitchTracker;
@@ -258,7 +259,17 @@ public:
     /**
      * @returns the TileManager associated to a given output
      */
-    TileManager *tileManager(Output *output);
+    TileManager *tileManager(Output *output) const;
+
+    /**
+     * Returns the root tile for the given @a output on the current virtual desktop.
+     */
+    RootTile *rootTile(Output *output) const;
+
+    /**
+     * Returns the root tile for the given @a output and @a desktop.
+     */
+    RootTile *rootTile(Output *output, VirtualDesktop *desktop) const;
 
 public:
     QPoint cascadeOffset(const QRectF &area) const;
-- 
GitLab


From eded599631cff53cff0d474e9a6e2d3b3e3b28be Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 17:29:31 +0200
Subject: [PATCH 19/32] scripting: Introduce workspace.rootTile()

Currently, the TileManager is exposed to the scripting api. But after
introducing per virtual desktop tile layouts, we realized that it would
be preferred to re-design the tile tree a bit. The TileManager limits
what we can do.

This change introduces the rootTile() query function, which returns a
tile object instead. It allows us to tweak the tiling design without
exposing other technical implementation details.
---
 src/scripting/workspace_wrapper.cpp |  9 +++++++++
 src/scripting/workspace_wrapper.h   | 13 +++++++++++++
 2 files changed, 22 insertions(+)

diff --git a/src/scripting/workspace_wrapper.cpp b/src/scripting/workspace_wrapper.cpp
index 092d2c4b41e..393406d7219 100644
--- a/src/scripting/workspace_wrapper.cpp
+++ b/src/scripting/workspace_wrapper.cpp
@@ -411,6 +411,8 @@ void WorkspaceWrapper::sendClientToScreen(Window *client, Output *output)
 
 KWin::TileManager *WorkspaceWrapper::tilingForScreen(const QString &screenName) const
 {
+    qCWarning(KWIN_CORE) << "workspace.tilingForScreen() is deprecated: use workspace.rootTile() instead";
+
     Output *output = kwinApp()->outputBackend()->findOutput(screenName);
     if (output) {
         auto tileManager = workspace()->tileManager(output);
@@ -422,11 +424,18 @@ KWin::TileManager *WorkspaceWrapper::tilingForScreen(const QString &screenName)
 
 KWin::TileManager *WorkspaceWrapper::tilingForScreen(Output *output) const
 {
+    qCWarning(KWIN_CORE) << "workspace.tilingForScreen() is deprecated: use workspace.rootTile() instead";
+
     auto tileManager = workspace()->tileManager(output);
     QJSEngine::setObjectOwnership(tileManager, QJSEngine::CppOwnership);
     return tileManager;
 }
 
+Tile *WorkspaceWrapper::rootTile(Output *output, VirtualDesktop *desktop) const
+{
+    return workspace()->rootTile(output, desktop);
+}
+
 QtScriptWorkspaceWrapper::QtScriptWorkspaceWrapper(QObject *parent)
     : WorkspaceWrapper(parent)
 {
diff --git a/src/scripting/workspace_wrapper.h b/src/scripting/workspace_wrapper.h
index 7b7bfb2d527..beccc3a146e 100644
--- a/src/scripting/workspace_wrapper.h
+++ b/src/scripting/workspace_wrapper.h
@@ -20,6 +20,7 @@
 namespace KWin
 {
 // forward declarations
+class Tile;
 class TileManager;
 class Window;
 class Output;
@@ -216,9 +217,21 @@ public:
 
     Q_INVOKABLE KWin::Output *screenAt(const QPointF &pos) const;
 
+    /**
+     * @deprecated since 6.3, use rootTile()
+     */
     Q_INVOKABLE KWin::TileManager *tilingForScreen(const QString &screenName) const;
+
+    /**
+     * @deprecated since 6.3, use rootTile()
+     */
     Q_INVOKABLE KWin::TileManager *tilingForScreen(KWin::Output *output) const;
 
+    /**
+     * Returns the root tile for the given @a output and @a desktop.
+     */
+    Q_INVOKABLE KWin::Tile *rootTile(KWin::Output *output, KWin::VirtualDesktop *desktop) const;
+
     /**
      * Returns the geometry a Client can use with the specified option.
      * This method should be preferred over other methods providing screen sizes as the
-- 
GitLab


From 9757f8b70de5e863c2b5ae4fa996a7fce5cc020b Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 17:34:33 +0200
Subject: [PATCH 20/32] plugins/tileseditor: Port away from
 workspace.tilingForScreen()

Workspace.tilingForScreen() is deprecated in favor of Workspace.rootTile().
---
 src/plugins/tileseditor/qml/main.qml | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/plugins/tileseditor/qml/main.qml b/src/plugins/tileseditor/qml/main.qml
index 1cb8eeb2767..46b3709bb7d 100644
--- a/src/plugins/tileseditor/qml/main.qml
+++ b/src/plugins/tileseditor/qml/main.qml
@@ -39,6 +39,8 @@ FocusScope {
 
     property bool active: false
 
+    readonly property QtObject rootTile: KWinComponents.Workspace.rootTile(root.targetScreen, KWinComponents.Workspace.currentDesktop)
+
     Component.onCompleted: {
         root.active = true;
     }
@@ -101,7 +103,7 @@ FocusScope {
     }
 
     TileDelegate {
-        tile: KWinComponents.Workspace.tilingForScreen(root.targetScreen.name).rootTile
+        tile: rootTile
         visible: tilesRepeater.count === 0 || tile.layoutDirection === KWinComponents.Tile.Floating
     }
 
@@ -119,7 +121,7 @@ FocusScope {
         Repeater {
             id: tilesRepeater
             model: KitemModels.KDescendantsProxyModel {
-                model: KWinComponents.Workspace.tilingForScreen(root.targetScreen.name).model
+                model: rootTile.model
             }
             delegate: TileDelegate {}
         }
@@ -153,8 +155,8 @@ FocusScope {
             PlasmaComponents.SpinBox {
                 from: 0
                 to: Kirigami.Units.gridUnit * 2
-                value: KWinComponents.Workspace.tilingForScreen(root.targetScreen.name).rootTile.padding
-                onValueModified: KWinComponents.Workspace.tilingForScreen(root.targetScreen.name).rootTile.padding = value
+                value: rootTile.padding
+                onValueModified: rootTile.padding = value
             }
             PlasmaComponents.Button {
                 icon.name: "document-open"
@@ -228,7 +230,6 @@ FocusScope {
                     image: "2columns"
                     KeyNavigation.right: apply3Columns
                     onClicked: {
-                        const rootTile = KWinComponents.Workspace.tilingForScreen(root.targetScreen.name).rootTile;
                         while (rootTile.tiles.length > 0) {
                             rootTile.tiles[0].remove();
                         }
@@ -242,7 +243,6 @@ FocusScope {
                     KeyNavigation.right: apply2ColumnsVerticalSplit
                     KeyNavigation.left: apply2Columns
                     onClicked: {
-                        const rootTile = KWinComponents.Workspace.tilingForScreen(root.targetScreen.name).rootTile;
                         while (rootTile.tiles.length > 0) {
                             rootTile.tiles[0].remove();
                         }
@@ -256,7 +256,6 @@ FocusScope {
                     image: "2columnsVerticalSplit"
                     KeyNavigation.left: apply3Columns
                     onClicked: {
-                        const rootTile = KWinComponents.Workspace.tilingForScreen(root.targetScreen.name).rootTile;
                         while (rootTile.tiles.length > 0) {
                             rootTile.tiles[0].remove();
                         }
-- 
GitLab


From 125d13457b5b48ea7837fcc8f9f8c180a49cd13f Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Thu, 19 Dec 2024 09:59:14 +0100
Subject: [PATCH 21/32] Don't store the current root tiles

m_rootTile and m_quickRootTile can be temporarly out of sync if they are
updated via a signal getting those calls wrong if they are invoked
between currentdesktopchanged emission and the signal handler in
virtualdesktopmanager

make rootTile() and quickRootTile() always return the proper root by
taking it indexed by VirtualDesktopManager::self()->currentDesktop()
---
 src/tiles/tilemanager.cpp | 24 ++++++++++++------------
 src/tiles/tilemanager.h   |  3 +--
 2 files changed, 13 insertions(+), 14 deletions(-)

diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index 6b178e4815b..c6f1de50471 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -79,9 +79,6 @@ TileManager::TileManager(Output *parent)
         addDesktop(desk);
     }
 
-    m_rootTile = m_rootTiles[VirtualDesktopManager::self()->currentDesktop()];
-    m_quickRootTile = m_quickRootTiles[VirtualDesktopManager::self()->currentDesktop()];
-
     connect(VirtualDesktopManager::self(), &VirtualDesktopManager::desktopAdded, this, addDesktop);
     connect(VirtualDesktopManager::self(), &VirtualDesktopManager::desktopRemoved,
             this, [this](VirtualDesktop *desk) {
@@ -92,10 +89,8 @@ TileManager::TileManager(Output *parent)
     });
     connect(VirtualDesktopManager::self(), &VirtualDesktopManager::currentChanged,
             this, [this](VirtualDesktop *oldDesk, VirtualDesktop *newDesk) {
-        m_rootTile = m_rootTiles[newDesk];
-        m_quickRootTile = m_quickRootTiles[newDesk];
-        Q_EMIT rootTileChanged(m_rootTile);
-        Q_EMIT modelChanged(m_rootTile->model());
+        Q_EMIT rootTileChanged(rootTile());
+        Q_EMIT modelChanged(model());
     });
 }
 
@@ -116,7 +111,7 @@ Output *TileManager::output() const
 
 Tile *TileManager::bestTileForPosition(const QPointF &pos)
 {
-    return m_rootTile->pick(pos);
+    return rootTile()->pick(pos);
 }
 
 Tile *TileManager::bestTileForPosition(qreal x, qreal y)
@@ -131,7 +126,12 @@ RootTile *TileManager::rootTile(VirtualDesktop *desktop) const
 
 RootTile *TileManager::rootTile() const
 {
-    return m_rootTile;
+    return m_rootTiles.value(VirtualDesktopManager::self()->currentDesktop());
+}
+
+QuickRootTile *TileManager::quickRootTile() const
+{
+    return m_quickRootTiles.value(VirtualDesktopManager::self()->currentDesktop());
 }
 
 QuickRootTile *TileManager::quickRootTile(VirtualDesktop *desktop) const
@@ -141,12 +141,12 @@ QuickRootTile *TileManager::quickRootTile(VirtualDesktop *desktop) const
 
 Tile *TileManager::quickTile(QuickTileMode mode) const
 {
-    return m_quickRootTile->tileForMode(mode);
+    return quickRootTile()->tileForMode(mode);
 }
 
 TileModel *TileManager::model() const
 {
-    return m_rootTile->model();
+    return rootTile()->model();
 }
 
 Tile *TileManager::tileForWindow(Window *window, VirtualDesktop *desktop)
@@ -377,7 +377,7 @@ QJsonObject TileManager::tileToJSon(CustomTile *tile)
 void TileManager::saveSettings()
 {
     KConfigGroup cg = kwinApp()->config()->group(QStringLiteral("Tiling"));
-    cg.writeEntry("padding", m_rootTile->padding());
+    cg.writeEntry("padding", rootTile()->padding());
 
     for (auto it = m_rootTiles.constBegin(); it != m_rootTiles.constEnd(); it++) {
         VirtualDesktop *desk = it.key();
diff --git a/src/tiles/tilemanager.h b/src/tiles/tilemanager.h
index df2b6786daf..c3f2d71a8ba 100644
--- a/src/tiles/tilemanager.h
+++ b/src/tiles/tilemanager.h
@@ -53,6 +53,7 @@ public:
     RootTile *rootTile(VirtualDesktop *desktop) const;
     RootTile *rootTile() const;
     QuickRootTile *quickRootTile(VirtualDesktop *desktop) const;
+    QuickRootTile *quickRootTile() const;
     KWin::Tile *quickTile(QuickTileMode mode) const;
 
     TileModel *model() const;
@@ -75,8 +76,6 @@ private:
 
     Output *m_output = nullptr;
     std::unique_ptr<QTimer> m_saveTimer;
-    RootTile *m_rootTile = nullptr;
-    QuickRootTile *m_quickRootTile = nullptr;
 
     QHash<VirtualDesktop *, RootTile *> m_rootTiles;
     QHash<VirtualDesktop *, QuickRootTile *> m_quickRootTiles;
-- 
GitLab


From d71321963d4b2058c7be372f978e447997c49c63 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 19 Dec 2024 22:56:26 +0200
Subject: [PATCH 22/32] Fix evacuation of quick tiled windows from removed
 desktops

Currently, if a quick tile is removed, its windows will be evacuated
to a custom tile, which is unexpected.
---
 autotests/integration/quick_tiling_test.cpp | 69 +++++++++++++++++++++
 src/tiles/tile.cpp                          | 14 +++--
 2 files changed, 79 insertions(+), 4 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index 5e2194c3038..20191e84fc7 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -108,6 +108,8 @@ private Q_SLOTS:
     void testMoveBetweenQuickTileAndCustomTileSameDesktopX11();
     void testMoveBetweenQuickTileAndCustomTileCrossDesktops();
     void testMoveBetweenQuickTileAndCustomTileCrossDesktopsX11();
+    void testEvacuateFromRemovedDesktop();
+    void testEvacuateFromRemovedDesktopX11();
     void testScript_data();
     void testScript();
     void testDontCrashWithMaximizeWindowRule();
@@ -2057,6 +2059,73 @@ void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileCrossDesktopsX11()
     }
 }
 
+void QuickTilingTest::testEvacuateFromRemovedDesktop()
+{
+    // This test verifies that a window is properly evacuated from a removed virtual desktop.
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy frameGeometryChangedSpy(window, &Window::frameGeometryChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(frameGeometryChangedSpy.wait());
+    };
+
+    const QRectF originalGeometry = window->frameGeometry();
+
+    // tile the window in the right half of the screen
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Right);
+    QCOMPARE(window->geometryRestore(), originalGeometry);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+
+    // remove the current virtual desktop
+    VirtualDesktopManager::self()->removeVirtualDesktop(VirtualDesktopManager::self()->currentDesktop());
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None); // technically, it should be "Right" but the tile object is gone
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    ackConfigure();
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), originalGeometry);
+}
+
+void QuickTilingTest::testEvacuateFromRemovedDesktopX11()
+{
+    // This test verifies that an X11 window is properly evacuated from a removed virtual desktop.
+
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+
+    const QRectF originalGeometry = window->frameGeometry();
+
+    // tile the window in the right half of the screen
+    window->setQuickTileModeAtCurrentPosition(QuickTileFlag::Right);
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::Right);
+    QCOMPARE(window->frameGeometry(), QRectF(640, 0, 640, 1024));
+
+    // remove the current virtual desktop
+    VirtualDesktopManager::self()->removeVirtualDesktop(VirtualDesktopManager::self()->currentDesktop());
+    QCOMPARE(window->quickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->requestedQuickTileMode(), QuickTileFlag::None);
+    QCOMPARE(window->frameGeometry(), originalGeometry);
+}
+
 void QuickTilingTest::testScript_data()
 {
     QTest::addColumn<QString>("action");
diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index 0975c9dda10..7c307183212 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -48,12 +48,18 @@ Tile::~Tile()
     if (m_tiling->tearingDown()) {
         return;
     }
+
+    // TODO: Look for alternative designs to evacuate windows from removed tiles.
     auto windows = m_windows;
     for (auto *w : windows) {
-        Tile *tile = m_tiling->bestTileForPosition(w->moveResizeGeometry().center());
-        removeWindow(w);
-        if (tile) {
-            tile->addWindow(w);
+        if (m_quickTileMode != QuickTileFlag::Custom) {
+            removeWindow(w);
+        } else {
+            Tile *tile = m_tiling->bestTileForPosition(w->moveResizeGeometry().center());
+            removeWindow(w);
+            if (tile) {
+                tile->addWindow(w);
+            }
         }
     }
 }
-- 
GitLab


From 5febf7626fe0340674b5e4cfe6c6bf818acb5513 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 20 Dec 2024 17:06:17 +0200
Subject: [PATCH 23/32] tiles: Port to RootTile::pick()

---
 autotests/integration/quick_tiling_test.cpp | 4 ++--
 src/tiles/customtile.cpp                    | 2 +-
 src/tiles/customtile.h                      | 2 +-
 src/tiles/tile.cpp                          | 2 +-
 src/window.cpp                              | 6 +++---
 5 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index 20191e84fc7..ca9c993ba85 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -1616,7 +1616,7 @@ void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileSameDesktop()
         for (Output *second : outputs) {
             const QPointF customPoint = first->geometry().center();
             const QPointF quickPoint = second->geometry().center();
-            Tile *customTile = workspace()->tileManager(first)->bestTileForPosition(customPoint);
+            Tile *customTile = workspace()->rootTile(first)->pick(customPoint);
             Tile *quickTile = workspace()->tileManager(second)->quickTile(QuickTileFlag::Left);
 
             window->setQuickTileMode(QuickTileFlag::Left, quickPoint);
@@ -1688,7 +1688,7 @@ void QuickTilingTest::testMoveBetweenQuickTileAndCustomTileSameDesktopX11()
         for (Output *second : outputs) {
             const QPointF customPoint = first->geometry().center();
             const QPointF quickPoint = second->geometry().center();
-            Tile *customTile = workspace()->tileManager(first)->bestTileForPosition(customPoint);
+            Tile *customTile = workspace()->rootTile(first)->pick(customPoint);
             Tile *quickTile = workspace()->tileManager(second)->quickTile(QuickTileFlag::Left);
 
             {
diff --git a/src/tiles/customtile.cpp b/src/tiles/customtile.cpp
index c3524b9863f..85315331717 100644
--- a/src/tiles/customtile.cpp
+++ b/src/tiles/customtile.cpp
@@ -332,7 +332,7 @@ void CustomTile::remove()
 
     const auto windows = std::exchange(m_windows, {});
     for (Window *window : windows) {
-        Tile *tile = m_tiling->bestTileForPosition(window->moveResizeGeometry().center());
+        Tile *tile = m_tiling->rootTile(m_desktop)->pick(window->moveResizeGeometry().center());
         if (tile) {
             tile->addWindow(window);
         }
diff --git a/src/tiles/customtile.h b/src/tiles/customtile.h
index fe982cea4d7..fa7e95d45da 100644
--- a/src/tiles/customtile.h
+++ b/src/tiles/customtile.h
@@ -58,7 +58,7 @@ private:
     bool m_geometryLock = false;
 };
 
-class RootTile : public CustomTile
+class KWIN_EXPORT RootTile : public CustomTile
 {
     Q_OBJECT
     Q_PROPERTY(KWin::TileModel *model READ model CONSTANT)
diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index 7c307183212..ec6b6f99420 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -436,7 +436,7 @@ void Tile::insertChild(int position, Tile *item)
         Q_EMIT isLayoutChanged(true);
         auto windows = m_windows;
         for (auto *w : windows) {
-            Tile *tile = m_tiling->bestTileForPosition(w->moveResizeGeometry().center());
+            Tile *tile = m_tiling->rootTile(m_desktop)->pick(w->moveResizeGeometry().center());
             removeWindow(w);
             if (tile) {
                 tile->addWindow(w);
diff --git a/src/window.cpp b/src/window.cpp
index 15fa67a0aac..3947c1bea91 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3593,7 +3593,7 @@ QRectF Window::quickTileGeometry(QuickTileMode mode, const QPointF &pos) const
     Output *output = workspace()->outputAt(pos);
 
     if (mode & QuickTileFlag::Custom) {
-        Tile *tile = workspace()->tileManager(output)->bestTileForPosition(pos);
+        Tile *tile = workspace()->rootTile(output)->pick(pos);
         if (tile) {
             return tile->windowGeometry();
         }
@@ -3756,7 +3756,7 @@ void Window::handleCustomQuickTileShortcut(QuickTileMode mode)
         return;
     }
     // if window is not tiled already, set it to nearest one
-    Tile *tileAtPoint = workspace()->tileManager(workspace()->outputAt(moveResizeGeometry().center()))->bestTileForPosition(moveResizeGeometry().center());
+    Tile *tileAtPoint = workspace()->rootTile(workspace()->outputAt(moveResizeGeometry().center()))->pick(moveResizeGeometry().center());
     if (!tileAtPoint) {
         return;
     }
@@ -3807,7 +3807,7 @@ void Window::setQuickTileMode(QuickTileMode mode, const QPointF &tileAtPoint)
 
     Tile *tile = nullptr;
     if (mode == QuickTileMode(QuickTileFlag::Custom)) {
-        tile = workspace()->tileManager(workspace()->outputAt(tileAtPoint))->bestTileForPosition(tileAtPoint);
+        tile = workspace()->rootTile(workspace()->outputAt(tileAtPoint))->pick(tileAtPoint);
     } else {
         tile = workspace()->tileManager(workspace()->outputAt(tileAtPoint))->quickTile(mode);
     }
-- 
GitLab


From df621676c298eb6c5c7d36f2e41e425745e464a7 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 20 Dec 2024 17:53:12 +0200
Subject: [PATCH 24/32] Preserve tiled state when window is closed

This kind of information can be useful for effects, etc.
---
 autotests/integration/quick_tiling_test.cpp | 68 +++++++++++++++++++++
 src/internalwindow.cpp                      |  1 -
 src/window.cpp                              |  5 +-
 src/x11window.cpp                           |  2 -
 src/xdgshellwindow.cpp                      |  1 -
 5 files changed, 72 insertions(+), 5 deletions(-)

diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index ca9c993ba85..8c51a31cd70 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -110,6 +110,8 @@ private Q_SLOTS:
     void testMoveBetweenQuickTileAndCustomTileCrossDesktopsX11();
     void testEvacuateFromRemovedDesktop();
     void testEvacuateFromRemovedDesktopX11();
+    void testCloseTiledWindow();
+    void testCloseTiledWindowX11();
     void testScript_data();
     void testScript();
     void testDontCrashWithMaximizeWindowRule();
@@ -2126,6 +2128,72 @@ void QuickTilingTest::testEvacuateFromRemovedDesktopX11()
     QCOMPARE(window->frameGeometry(), originalGeometry);
 }
 
+void QuickTilingTest::testCloseTiledWindow()
+{
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::blue);
+
+    // We have to receive a configure event when the window becomes active.
+    QSignalSpy frameGeometryChangedSpy(window, &Window::frameGeometryChanged);
+    QSignalSpy toplevelConfigureRequestedSpy(shellSurface.get(), &Test::XdgToplevel::configureRequested);
+    QSignalSpy surfaceConfigureRequestedSpy(shellSurface->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+    QCOMPARE(surfaceConfigureRequestedSpy.count(), 1);
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        shellSurface->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().at(0).toSize(), Qt::blue);
+        QVERIFY(frameGeometryChangedSpy.wait());
+    };
+
+    Tile *tile = workspace()->tileManager(workspace()->activeOutput())->quickTile(QuickTileFlag::Right);
+
+    const QRectF originalGeometry = window->frameGeometry();
+    tile->addWindow(window);
+    QCOMPARE(window->geometryRestore(), originalGeometry);
+    QCOMPARE(window->tile(), nullptr);
+    QCOMPARE(window->requestedTile(), tile);
+    ackConfigure();
+    QCOMPARE(window->tile(), tile);
+    QCOMPARE(window->requestedTile(), tile);
+    QCOMPARE(window->frameGeometry(), tile->windowGeometry());
+
+    window->ref();
+    shellSurface.reset();
+    surface.reset();
+    QVERIFY(Test::waitForWindowClosed(window));
+    QVERIFY(!tile->windows().contains(window));
+    QCOMPARE(window->tile(), tile);
+    QCOMPARE(window->requestedTile(), tile);
+    QCOMPARE(window->frameGeometry(), tile->windowGeometry());
+    window->unref();
+}
+
+void QuickTilingTest::testCloseTiledWindowX11()
+{
+    Test::XcbConnectionPtr connection = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(connection.get()));
+    X11Window *window = createWindow(connection.get(), QRect(0, 0, 100, 200));
+
+    Tile *tile = workspace()->tileManager(workspace()->activeOutput())->quickTile(QuickTileFlag::Right);
+
+    tile->addWindow(window);
+    QCOMPARE(window->tile(), tile);
+    QCOMPARE(window->requestedTile(), tile);
+    QCOMPARE(window->frameGeometry(), tile->windowGeometry());
+
+    window->ref();
+    connection.reset();
+    QVERIFY(Test::waitForWindowClosed(window));
+    QVERIFY(!tile->windows().contains(window));
+    QCOMPARE(window->tile(), tile);
+    QCOMPARE(window->requestedTile(), tile);
+    QCOMPARE(window->frameGeometry(), tile->windowGeometry());
+    window->unref();
+}
+
 void QuickTilingTest::testScript_data()
 {
     QTest::addColumn<QString>("action");
diff --git a/src/internalwindow.cpp b/src/internalwindow.cpp
index 07497ed7a7d..82d8affc292 100644
--- a/src/internalwindow.cpp
+++ b/src/internalwindow.cpp
@@ -351,7 +351,6 @@ void InternalWindow::destroyWindow()
 
     Q_EMIT closed();
 
-    commitTile(nullptr);
     workspace()->removeInternalWindow(this);
     m_handle = nullptr;
 
diff --git a/src/window.cpp b/src/window.cpp
index 3947c1bea91..6d9a0c166d8 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -103,7 +103,6 @@ Window::Window()
 
 Window::~Window()
 {
-    Q_ASSERT(!m_tile);
 }
 
 void Window::ref()
@@ -3868,6 +3867,10 @@ Tile *Window::requestedTile() const
 
 void Window::requestTile(Tile *tile)
 {
+    if (isDeleted()) {
+        return;
+    }
+
     // Forbid tiling unmanaged windows
     if (!isClient()) {
         return;
diff --git a/src/x11window.cpp b/src/x11window.cpp
index 8f84f84d754..7d8fffa6ca5 100644
--- a/src/x11window.cpp
+++ b/src/x11window.cpp
@@ -249,7 +249,6 @@ void X11Window::releaseWindow(bool on_shutdown)
         if (isInteractiveMoveResize()) {
             Q_EMIT interactiveMoveResizeFinished();
         }
-        commitTile(nullptr);
         workspace()->rulebook()->discardUsed(this, true); // Remove ForceTemporarily rules
         StackingUpdatesBlocker blocker(workspace());
         stopDelayedInteractiveMoveResize();
@@ -327,7 +326,6 @@ void X11Window::destroyWindow()
         if (isInteractiveMoveResize()) {
             Q_EMIT interactiveMoveResizeFinished();
         }
-        commitTile(nullptr);
         workspace()->rulebook()->discardUsed(this, true); // Remove ForceTemporarily rules
         StackingUpdatesBlocker blocker(workspace());
         stopDelayedInteractiveMoveResize();
diff --git a/src/xdgshellwindow.cpp b/src/xdgshellwindow.cpp
index d5dcc109838..45c111c501f 100644
--- a/src/xdgshellwindow.cpp
+++ b/src/xdgshellwindow.cpp
@@ -308,7 +308,6 @@ void XdgSurfaceWindow::destroyWindow()
         leaveInteractiveMoveResize();
         Q_EMIT interactiveMoveResizeFinished();
     }
-    commitTile(nullptr);
     m_configureTimer->stop();
     qDeleteAll(m_configureEvents);
     m_configureEvents.clear();
-- 
GitLab


From 9f9814acd7f14953926d8394d66929cf67b3e0c6 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 20 Dec 2024 18:02:03 +0200
Subject: [PATCH 25/32] Drop redundant checks when tiling

The Tile already checks whether the window is suitable for tiling. In
order to ensure that the checks don't get out of sync, this change drops
unnecessary checks in the Window type. It should be okay because all
tiling updates must go through the Tile.
---
 src/window.cpp | 11 +----------
 1 file changed, 1 insertion(+), 10 deletions(-)

diff --git a/src/window.cpp b/src/window.cpp
index 6d9a0c166d8..766d5472b03 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -3694,10 +3694,6 @@ static QuickTileMode combineQuickTileMode(QuickTileMode mode, QuickTileMode othe
 
 void Window::handleQuickTileShortcut(QuickTileMode mode)
 {
-    // Only allow quick tile on a regular window.
-    if (!isResizable() || isAppletPopup()) {
-        return;
-    }
     QPointF tileAtPoint = moveResizeGeometry().center();
     if (mode != QuickTileFlag::None) {
         const QuickTileMode oldMode = requestedQuickTileMode();
@@ -3750,8 +3746,7 @@ void Window::handleQuickTileShortcut(QuickTileMode mode)
 
 void Window::handleCustomQuickTileShortcut(QuickTileMode mode)
 {
-    // Only allow quick tile on a regular window.
-    if (!isResizable() || isAppletPopup() || mode == QuickTileFlag::None) {
+    if (mode == QuickTileFlag::None) {
         return;
     }
     // if window is not tiled already, set it to nearest one
@@ -3871,10 +3866,6 @@ void Window::requestTile(Tile *tile)
         return;
     }
 
-    // Forbid tiling unmanaged windows
-    if (!isClient()) {
-        return;
-    }
     if (m_requestedTile == tile) {
         return;
     }
-- 
GitLab


From 8b79c3800068d281aa1cbf8491bd15693b4c530a Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Tue, 17 Dec 2024 17:02:32 +0100
Subject: [PATCH 26/32] autotests: add a test for per-desktop tiles

test per-desktop custom tiles,
and what happens when canging desktops
uses a new default 2 columns tile layout, old tests still use that more complex
one

* set a tile on desktop 1, go to desktop 2 the window is untiled
* going back to desktop 1 the window regains old tile
* having tiles in both desktop 1 and desktop 2, the tile will change
  accordingly with current desktop
---
 autotests/integration/tiles_test.cpp | 130 +++++++++++++++++++++++++--
 1 file changed, 121 insertions(+), 9 deletions(-)

diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index f2ba18860c1..d66b0c570d6 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -17,6 +17,9 @@
 
 #include <QAbstractItemModelTester>
 
+Q_DECLARE_METATYPE(KWin::QuickTileMode)
+Q_DECLARE_METATYPE(KWin::MaximizeMode)
+
 namespace KWin
 {
 
@@ -33,9 +36,11 @@ private Q_SLOTS:
     void testAssignedTileDeletion();
     void resizeTileFromWindow();
     void shortcuts();
+    void testPerDesktopTiles();
 
 private:
-    void createSampleLayout();
+    void createSimpleLayout();
+    void createComplexLayout();
 
     Output *m_output;
     TileManager *m_tileManager;
@@ -69,22 +74,52 @@ void TilesTest::init()
     m_tileManager = workspace()->tileManager(m_output);
     m_rootTile = workspace()->rootTile(m_output);
     QAbstractItemModelTester(m_tileManager->model(), QAbstractItemModelTester::FailureReportingMode::QtTest);
-    while (m_rootTile->childCount() > 0) {
-        static_cast<CustomTile *>(m_rootTile->childTile(0))->remove();
-    }
-    createSampleLayout();
+
+    VirtualDesktopManager::self()->setCount(3);
+    VirtualDesktopManager::self()->setCurrent(1);
+    createSimpleLayout();
 }
 
 void TilesTest::cleanup()
 {
-    while (m_rootTile->childCount() > 0) {
-        static_cast<CustomTile *>(m_rootTile->childTile(0))->remove();
-    }
     Test::destroyWaylandConnection();
 }
 
-void TilesTest::createSampleLayout()
+void TilesTest::createSimpleLayout()
+{
+    std::vector<qreal> leftTileWidths = {0.5, 0.45, 0.4, 0.35, 0.3, 0.25};
+    int i = 0;
+    for (VirtualDesktop *desk : VirtualDesktopManager::self()->desktops()) {
+        for (Output *out : workspace()->outputs()) {
+            qreal leftTileWidth = leftTileWidths[i++];
+            CustomTile *rootTile = workspace()->rootTile(out, desk);
+            while (rootTile->childCount() > 0) {
+                static_cast<CustomTile *>(rootTile->childTile(0))->remove();
+            }
+
+            QCOMPARE(rootTile->childCount(), 0);
+            rootTile->split(CustomTile::LayoutDirection::Horizontal);
+            QCOMPARE(rootTile->childCount(), 2);
+
+            auto leftTile = qobject_cast<CustomTile *>(rootTile->childTiles().first());
+            auto rightTile = qobject_cast<CustomTile *>(rootTile->childTiles().last());
+            QVERIFY(leftTile);
+            QVERIFY(rightTile);
+
+            leftTile->setRelativeGeometry(QRectF(0, 0, leftTileWidth, 1));
+
+            QCOMPARE(leftTile->relativeGeometry(), QRectF(0, 0, leftTileWidth, 1));
+            QCOMPARE(rightTile->relativeGeometry(), QRectF(leftTileWidth, 0, 1 - leftTileWidth, 1));
+        }
+    }
+}
+
+void TilesTest::createComplexLayout()
 {
+    while (m_rootTile->childCount() > 0) {
+        static_cast<CustomTile *>(m_rootTile->childTile(0))->remove();
+    }
+
     QCOMPARE(m_rootTile->childCount(), 0);
     m_rootTile->split(CustomTile::LayoutDirection::Horizontal);
     QCOMPARE(m_rootTile->childCount(), 2);
@@ -136,6 +171,7 @@ void TilesTest::createSampleLayout()
 
 void TilesTest::testWindowInteraction()
 {
+    createComplexLayout();
     // Test that resizing a tile resizes the contained window and resizes the neighboring tiles as well
     std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
 
@@ -201,6 +237,8 @@ void TilesTest::testWindowInteraction()
 
 void TilesTest::testAssignedTileDeletion()
 {
+    createComplexLayout();
+
     auto leftTile = qobject_cast<CustomTile *>(m_rootTile->childTiles().first());
     QVERIFY(leftTile);
     leftTile->setRelativeGeometry({0, 0, 0.4, 1});
@@ -263,6 +301,8 @@ void TilesTest::testAssignedTileDeletion()
 
 void TilesTest::resizeTileFromWindow()
 {
+    createComplexLayout();
+
     auto middleBottomTile = qobject_cast<CustomTile *>(m_rootTile->childTiles()[1]->childTiles()[1]);
     QVERIFY(middleBottomTile);
     middleBottomTile->remove();
@@ -411,6 +451,8 @@ void TilesTest::resizeTileFromWindow()
 
 void TilesTest::shortcuts()
 {
+    createComplexLayout();
+
     // Our tile layout
     // | | | |
     // | |-| |
@@ -486,6 +528,76 @@ void TilesTest::shortcuts()
     QVERIFY(!bottomCenterTile->windows().contains(window));
     QVERIFY(leftTile->windows().contains(window));
 }
+
+void TilesTest::testPerDesktopTiles()
+{
+    auto rootTileD1 = m_tileManager->rootTile(VirtualDesktopManager::self()->desktops()[0]);
+    auto rightTileD1 = rootTileD1->childTiles()[1];
+
+    auto rootTileD2 = m_tileManager->rootTile(VirtualDesktopManager::self()->desktops()[1]);
+    auto leftTileD2 = rootTileD2->childTiles()[0];
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> root(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::cyan);
+    window->setOnAllDesktops(true);
+
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy surfaceConfigureRequestedSpy(root->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QSignalSpy toplevelConfigureRequestedSpy(root.get(), &Test::XdgToplevel::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        root->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().first().value<QSize>(), Qt::blue);
+    };
+
+    // Add the window to a tile in desktop 1
+    {
+        rightTileD1->addWindow(window);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), rightTileD1);
+        QCOMPARE(window->frameGeometry(), rightTileD1->windowGeometry());
+    }
+
+    // Set current Desktop 2
+    {
+        VirtualDesktopManager::self()->setCurrent(2);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), nullptr);
+        QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
+    }
+
+    // Set a new tile for Desktop 2
+    {
+        leftTileD2->addWindow(window);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), leftTileD2);
+        QCOMPARE(window->frameGeometry(), leftTileD2->windowGeometry());
+    }
+
+    // Go back to desktop 1, we go back to rightTileD1
+    {
+        VirtualDesktopManager::self()->setCurrent(1);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), rightTileD1);
+        QCOMPARE(window->frameGeometry(), rightTileD1->windowGeometry());
+    }
+
+    // Switch to desktop 2
+    {
+        VirtualDesktopManager::self()->setCurrent(2);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), leftTileD2);
+        QCOMPARE(window->frameGeometry(), leftTileD2->windowGeometry());
+    }
+}
 }
 
 WAYLANDTEST_MAIN(KWin::TilesTest)
-- 
GitLab


From a9058cab5e4c63f424f729c38abf9152dd0ae696 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Fri, 20 Dec 2024 14:32:13 +0100
Subject: [PATCH 27/32] autotests: test sending a tiled window to another
 output

---
 autotests/integration/CMakeLists.txt |   2 +-
 autotests/integration/tiles_test.cpp | 143 +++++++++++++++++++++++++++
 2 files changed, 144 insertions(+), 1 deletion(-)

diff --git a/autotests/integration/CMakeLists.txt b/autotests/integration/CMakeLists.txt
index 75d2bd13be2..ca63b7aee04 100644
--- a/autotests/integration/CMakeLists.txt
+++ b/autotests/integration/CMakeLists.txt
@@ -122,7 +122,7 @@ integrationTest(NAME testInputMethod SRCS inputmethod_test.cpp LIBS XKB::XKB)
 integrationTest(NAME testScreens SRCS screens_test.cpp)
 integrationTest(NAME testScreenEdges SRCS screenedges_test.cpp LIBS XCB::ICCCM)
 integrationTest(NAME testOutputChanges SRCS outputchanges_test.cpp LIBS XCB::ICCCM Qt::Sensors)
-integrationTest(NAME testTiles SRCS tiles_test.cpp)
+integrationTest(NAME testTiles SRCS tiles_test.cpp LIBS XCB::ICCCM)
 integrationTest(NAME testFractionalScaling SRCS fractional_scaling_test.cpp)
 integrationTest(NAME testMoveResize SRCS move_resize_window_test.cpp LIBS XCB::ICCCM)
 integrationTest(NAME testStruts SRCS struts_test.cpp LIBS XCB::ICCCM KDecoration3::KDecoration)
diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index d66b0c570d6..77d6a9d871e 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -15,6 +15,12 @@
 #include "window.h"
 #include "workspace.h"
 
+#if KWIN_BUILD_X11
+#include "x11window.h"
+#include <netwm.h>
+#include <xcb/xcb_icccm.h>
+#endif
+
 #include <QAbstractItemModelTester>
 
 Q_DECLARE_METATYPE(KWin::QuickTileMode)
@@ -25,6 +31,38 @@ namespace KWin
 
 static const QString s_socketName = QStringLiteral("wayland_test_kwin_transient_placement-0");
 
+#if KWIN_BUILD_X11
+static X11Window *createWindow(xcb_connection_t *connection, const QRect &geometry, std::function<void(xcb_window_t)> setup = {})
+{
+    xcb_window_t windowId = xcb_generate_id(connection);
+    xcb_create_window(connection, XCB_COPY_FROM_PARENT, windowId, rootWindow(),
+                      geometry.x(),
+                      geometry.y(),
+                      geometry.width(),
+                      geometry.height(),
+                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, XCB_COPY_FROM_PARENT, 0, nullptr);
+
+    xcb_size_hints_t hints;
+    memset(&hints, 0, sizeof(hints));
+    xcb_icccm_size_hints_set_position(&hints, 1, geometry.x(), geometry.y());
+    xcb_icccm_size_hints_set_size(&hints, 1, geometry.width(), geometry.height());
+    xcb_icccm_set_wm_normal_hints(connection, windowId, &hints);
+
+    if (setup) {
+        setup(windowId);
+    }
+
+    xcb_map_window(connection, windowId);
+    xcb_flush(connection);
+
+    QSignalSpy windowCreatedSpy(workspace(), &Workspace::windowAdded);
+    if (!windowCreatedSpy.wait()) {
+        return nullptr;
+    }
+    return windowCreatedSpy.last().first().value<X11Window *>();
+}
+#endif
+
 class TilesTest : public QObject
 {
     Q_OBJECT
@@ -37,6 +75,8 @@ private Q_SLOTS:
     void resizeTileFromWindow();
     void shortcuts();
     void testPerDesktopTiles();
+    void sendToOutput();
+    void sendToOutputX11();
 
 private:
     void createSimpleLayout();
@@ -598,6 +638,109 @@ void TilesTest::testPerDesktopTiles()
         QCOMPARE(window->frameGeometry(), leftTileD2->windowGeometry());
     }
 }
+
+void TilesTest::sendToOutput()
+{
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> root(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::cyan);
+    window->setOnAllDesktops(true);
+
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy surfaceConfigureRequestedSpy(root->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QSignalSpy toplevelConfigureRequestedSpy(root.get(), &Test::XdgToplevel::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        root->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().first().value<QSize>(), Qt::blue);
+    };
+
+    const auto desktops = VirtualDesktopManager::self()->desktops();
+    const auto outputs = workspace()->outputs();
+    Tile *firstTile = workspace()->rootTile(outputs[0], desktops[0])->childTiles()[0];
+    Tile *secondTile = workspace()->rootTile(outputs[0], desktops[1])->childTiles()[1];
+
+    // Tile window on desktop 1
+    {
+        VirtualDesktopManager::self()->setCurrent(desktops[0]);
+        firstTile->addWindow(window);
+        QCOMPARE(window->tile(), nullptr);
+        QCOMPARE(window->requestedTile(), firstTile);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), firstTile);
+        QCOMPARE(window->requestedTile(), firstTile);
+        QCOMPARE(window->frameGeometry(), firstTile->windowGeometry());
+    }
+
+    // Tile window on desktop 2
+    {
+        VirtualDesktopManager::self()->setCurrent(desktops[1]);
+        secondTile->addWindow(window);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), secondTile);
+        QCOMPARE(window->requestedTile(), secondTile);
+        QCOMPARE(window->frameGeometry(), secondTile->windowGeometry());
+    }
+
+    // Send window to the second output
+    {
+        window->sendToOutput(outputs[1]);
+        QVERIFY(!firstTile->windows().contains(window));
+        QVERIFY(!secondTile->windows().contains(window));
+        QCOMPARE(window->tile(), secondTile);
+        QCOMPARE(window->requestedTile(), nullptr);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), nullptr);
+        QCOMPARE(window->requestedTile(), nullptr);
+    }
+}
+
+void TilesTest::sendToOutputX11()
+{
+#if KWIN_BUILD_X11
+    Test::XcbConnectionPtr c = Test::createX11Connection();
+    QVERIFY(!xcb_connection_has_error(c.get()));
+    X11Window *window = createWindow(c.get(), QRect(0, 0, 100, 200));
+    window->setOnAllDesktops(true);
+
+    const auto desktops = VirtualDesktopManager::self()->desktops();
+    const auto outputs = workspace()->outputs();
+    Tile *firstTile = workspace()->rootTile(outputs[0], desktops[0])->childTiles()[0];
+    Tile *secondTile = workspace()->rootTile(outputs[0], desktops[1])->childTiles()[1];
+
+    // Tile window on desktop 1
+    {
+        VirtualDesktopManager::self()->setCurrent(desktops[0]);
+        firstTile->addWindow(window);
+        QCOMPARE(window->tile(), firstTile);
+        QCOMPARE(window->requestedTile(), firstTile);
+        QCOMPARE(window->frameGeometry(), firstTile->windowGeometry());
+    }
+
+    // Tile window on desktop 2
+    {
+        VirtualDesktopManager::self()->setCurrent(desktops[1]);
+        secondTile->addWindow(window);
+        QCOMPARE(window->tile(), secondTile);
+        QCOMPARE(window->requestedTile(), secondTile);
+        QCOMPARE(window->frameGeometry(), secondTile->windowGeometry());
+    }
+
+    // Send window to the second output
+    {
+        window->sendToOutput(outputs[1]);
+        QVERIFY(!firstTile->windows().contains(window));
+        QVERIFY(!secondTile->windows().contains(window));
+        QCOMPARE(window->tile(), nullptr);
+        QCOMPARE(window->requestedTile(), nullptr);
+    }
+#endif
+}
 }
 
 WAYLANDTEST_MAIN(KWin::TilesTest)
-- 
GitLab


From 05282b703e31c65d2d39c99b335f86ab21d78081 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Fri, 20 Dec 2024 14:35:54 +0100
Subject: [PATCH 28/32] autotests: test interaction between tiles and maximized
 windows

* tile a window on desktop 1 and 2
* maximize the window
* the window is untiled
* all tiles lost that window, on every desktop
---
 autotests/integration/tiles_test.cpp | 84 ++++++++++++++++++++++++++++
 1 file changed, 84 insertions(+)

diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index 77d6a9d871e..188f8c54fa6 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -77,6 +77,7 @@ private Q_SLOTS:
     void testPerDesktopTiles();
     void sendToOutput();
     void sendToOutputX11();
+    void tileAndMaximize();
 
 private:
     void createSimpleLayout();
@@ -741,6 +742,89 @@ void TilesTest::sendToOutputX11()
     }
 #endif
 }
+
+void TilesTest::tileAndMaximize()
+{
+    // This tests the interaction between the tiled and maximized states
+    auto rootTileD2 = m_tileManager->rootTile(VirtualDesktopManager::self()->desktops()[1]);
+    auto rightTileD2 = qobject_cast<CustomTile *>(rootTileD2->childTiles()[1]);
+
+    auto leftQuickTileD1 = m_tileManager->quickTile(QuickTileFlag::Left);
+
+    const QList<Output *> outputs = workspace()->outputs();
+    TileManager *out2TileMan = workspace()->tileManager(outputs[1]);
+    auto rootTileD3O2 = out2TileMan->rootTile(VirtualDesktopManager::self()->desktops()[2]);
+    auto leftTileD3O2 = qobject_cast<CustomTile *>(rootTileD3O2->childTiles()[0]);
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> root(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::cyan);
+    window->setOnAllDesktops(true);
+
+    QSignalSpy tileChangedSpy(window, &Window::tileChanged);
+    QSignalSpy surfaceConfigureRequestedSpy(root->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QSignalSpy toplevelConfigureRequestedSpy(root.get(), &Test::XdgToplevel::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        root->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().first().value<QSize>(), Qt::blue);
+    };
+
+    // Add the window to a quick tile in desktop 1 and a cutom tile on desktop 2
+    {
+        leftQuickTileD1->addWindow(window);
+        rightTileD2->addWindow(window);
+        QCOMPARE(window->requestedTile(), leftQuickTileD1);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), leftQuickTileD1);
+        QCOMPARE(window->frameGeometry(), leftQuickTileD1->windowGeometry());
+    }
+
+    // Set current Desktop 2
+    {
+        VirtualDesktopManager::self()->setCurrent(2);
+        // Tile becomes rightTileD2
+        QCOMPARE(window->requestedTile(), rightTileD2);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), rightTileD2);
+        QCOMPARE(window->frameGeometry(), rightTileD2->windowGeometry());
+    }
+
+    // Add the window also on a tile of another output
+    leftTileD3O2->addWindow(window);
+
+    // Maximize the window, it should lose its tile
+    {
+        window->maximize(MaximizeFull);
+        // No requestedTile anymore
+        QCOMPARE(window->requestedTile(), nullptr);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), nullptr);
+        QCOMPARE(window->frameGeometry(), QRectF(0, 0, 1280, 1024));
+
+        // Both tiles have an empty window list now
+        QVERIFY(leftQuickTileD1->windows().isEmpty());
+        QVERIFY(rightTileD2->windows().isEmpty());
+        // Also the tile on the other output llost the window
+        QVERIFY(leftTileD3O2->windows().isEmpty());
+    }
+
+    // Set a tile again, it should unmaximize
+    {
+        rightTileD2->addWindow(window);
+        QCOMPARE(window->requestedTile(), rightTileD2);
+        ackConfigure();
+        QVERIFY(tileChangedSpy.wait());
+        QCOMPARE(window->tile(), rightTileD2);
+        QCOMPARE(window->maximizeMode(), MaximizeRestore);
+        QCOMPARE(window->frameGeometry(), rightTileD2->windowGeometry());
+    }
+}
 }
 
 WAYLANDTEST_MAIN(KWin::TilesTest)
-- 
GitLab


From 8f47fcf958cf16e49538e01f6d8b4c8466596f36 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Fri, 20 Dec 2024 15:25:39 +0100
Subject: [PATCH 29/32] autotests: test evacuating windows from tiles on
 removed desktops

* if a window is tiled on desktop 2 and 3, and we are on desktop 3
* removing the desktop 3 we are on desktop 2 with the window tled on
  desktop 2
* if now we remove the desktop 2, the window should be untiled
---
 autotests/integration/tiles_test.cpp | 64 ++++++++++++++++++++++++++++
 1 file changed, 64 insertions(+)

diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index 188f8c54fa6..eed97008488 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -78,6 +78,7 @@ private Q_SLOTS:
     void sendToOutput();
     void sendToOutputX11();
     void tileAndMaximize();
+    void evacuateFromRemovedDesktop();
 
 private:
     void createSimpleLayout();
@@ -825,6 +826,69 @@ void TilesTest::tileAndMaximize()
         QCOMPARE(window->frameGeometry(), rightTileD2->windowGeometry());
     }
 }
+
+void TilesTest::evacuateFromRemovedDesktop()
+{
+    const auto desktops = VirtualDesktopManager::self()->desktops();
+    auto rightTileD2 = m_tileManager->rootTile(desktops[1])->childTiles()[1];
+    auto leftTileD3 = m_tileManager->rootTile(desktops[2])->childTiles()[0];
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> root(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::cyan);
+    window->setOnAllDesktops(true);
+
+    QSignalSpy surfaceConfigureRequestedSpy(root->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QSignalSpy toplevelConfigureRequestedSpy(root.get(), &Test::XdgToplevel::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        root->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().first().value<QSize>(), Qt::blue);
+        QVERIFY(Test::waylandSync());
+    };
+
+    // Set current Desktop 2
+    // Add the window to a tile in desktop 2 and desktop 3
+    {
+        VirtualDesktopManager::self()->setCurrent(2);
+        rightTileD2->addWindow(window);
+        leftTileD3->addWindow(window);
+        QCOMPARE(window->requestedTile(), rightTileD2);
+        ackConfigure();
+        QCOMPARE(window->tile(), rightTileD2);
+        QCOMPARE(window->frameGeometry(), rightTileD2->windowGeometry());
+    }
+
+    // Set current Desktop 3
+    {
+        VirtualDesktopManager::self()->setCurrent(3);
+        // Tile becomes leftTileD3
+        QCOMPARE(window->requestedTile(), leftTileD3);
+        ackConfigure();
+        QCOMPARE(window->tile(), leftTileD3);
+        QCOMPARE(window->frameGeometry(), leftTileD3->windowGeometry());
+    }
+
+    // Remove the current desktop 3, the window will be tiled again to rightTileD2
+    {
+        VirtualDesktopManager::self()->setCount(2);
+        QCOMPARE(window->requestedTile(), rightTileD2);
+        ackConfigure();
+        QCOMPARE(window->tile(), rightTileD2);
+        QCOMPARE(window->frameGeometry(), rightTileD2->windowGeometry());
+    }
+
+    // Remove the current desktop 2, the window is now untiles
+    {
+        VirtualDesktopManager::self()->setCount(1);
+        QCOMPARE(window->requestedTile(), nullptr);
+        ackConfigure();
+        QCOMPARE(window->tile(), nullptr);
+        QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
+    }
+}
 }
 
 WAYLANDTEST_MAIN(KWin::TilesTest)
-- 
GitLab


From 0896e37ed5740fe364cbea4641629c4387bf0eac Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Fri, 20 Dec 2024 15:48:25 +0100
Subject: [PATCH 30/32] autotests: test evacuating windows from tiles on
 removed output

If a window is tile on a second output, and that output is removed,
the window should be completely untiled
---
 autotests/integration/tiles_test.cpp | 49 ++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index eed97008488..9c14ff53195 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -79,6 +79,7 @@ private Q_SLOTS:
     void sendToOutputX11();
     void tileAndMaximize();
     void evacuateFromRemovedDesktop();
+    void evacuateFromRemovedOutput();
 
 private:
     void createSimpleLayout();
@@ -889,6 +890,54 @@ void TilesTest::evacuateFromRemovedDesktop()
         QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
     }
 }
+
+void TilesTest::evacuateFromRemovedOutput()
+{
+    const QList<Output *> outputs = workspace()->outputs();
+    auto rightTileD1O2 = workspace()->rootTile(outputs[1])->childTiles()[1];
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> root(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 100), Qt::cyan);
+    window->setOnAllDesktops(true);
+
+    QSignalSpy surfaceConfigureRequestedSpy(root->xdgSurface(), &Test::XdgSurface::configureRequested);
+    QSignalSpy toplevelConfigureRequestedSpy(root.get(), &Test::XdgToplevel::configureRequested);
+    QVERIFY(surfaceConfigureRequestedSpy.wait());
+
+    auto ackConfigure = [&]() {
+        QVERIFY(surfaceConfigureRequestedSpy.wait());
+        root->xdgSurface()->ack_configure(surfaceConfigureRequestedSpy.last().at(0).value<quint32>());
+        Test::render(surface.get(), toplevelConfigureRequestedSpy.last().first().value<QSize>(), Qt::blue);
+        QVERIFY(Test::waylandSync());
+    };
+
+    // tile a window in output 2
+    {
+        rightTileD1O2->addWindow(window);
+        QCOMPARE(window->requestedTile(), rightTileD1O2);
+        ackConfigure();
+        QCOMPARE(window->tile(), rightTileD1O2);
+        QCOMPARE(window->frameGeometry(), rightTileD1O2->windowGeometry());
+    }
+
+    // Remove output 2, the window should lose the tile
+    {
+        Test::setOutputConfig({
+            QRect(0, 0, 1280, 1024),
+        });
+
+        QCOMPARE(window->requestedTile(), nullptr);
+        ackConfigure();
+        QCOMPARE(window->tile(), nullptr);
+        QCOMPARE(window->frameGeometry(), QRectF(0, 0, 100, 100));
+    }
+
+    Test::setOutputConfig({
+        QRect(0, 0, 1280, 1024),
+        QRect(1280, 0, 1280, 1024),
+    });
+}
 }
 
 WAYLANDTEST_MAIN(KWin::TilesTest)
-- 
GitLab


From 9a304257561d59d0feebf2773726d123fbb53e09 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Fri, 20 Dec 2024 15:54:14 +0100
Subject: [PATCH 31/32] When migrating from destroyed tiles, don't cross to
 another root

When a tile gets destroyed, it should try to migrate its windows
to another tile, unless the complete tile tree is destroyed: in this
case it shouldn't try to migrate it to another tile tree
---
 autotests/integration/tiles_test.cpp | 8 ++++----
 src/tiles/tile.cpp                   | 5 ++++-
 src/tiles/tilemanager.cpp            | 6 ++----
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/autotests/integration/tiles_test.cpp b/autotests/integration/tiles_test.cpp
index 9c14ff53195..4d951606f3a 100644
--- a/autotests/integration/tiles_test.cpp
+++ b/autotests/integration/tiles_test.cpp
@@ -853,7 +853,7 @@ void TilesTest::evacuateFromRemovedDesktop()
     // Set current Desktop 2
     // Add the window to a tile in desktop 2 and desktop 3
     {
-        VirtualDesktopManager::self()->setCurrent(2);
+        VirtualDesktopManager::self()->setCurrent(desktops[1]);
         rightTileD2->addWindow(window);
         leftTileD3->addWindow(window);
         QCOMPARE(window->requestedTile(), rightTileD2);
@@ -864,7 +864,7 @@ void TilesTest::evacuateFromRemovedDesktop()
 
     // Set current Desktop 3
     {
-        VirtualDesktopManager::self()->setCurrent(3);
+        VirtualDesktopManager::self()->setCurrent(desktops[2]);
         // Tile becomes leftTileD3
         QCOMPARE(window->requestedTile(), leftTileD3);
         ackConfigure();
@@ -874,7 +874,7 @@ void TilesTest::evacuateFromRemovedDesktop()
 
     // Remove the current desktop 3, the window will be tiled again to rightTileD2
     {
-        VirtualDesktopManager::self()->setCount(2);
+        VirtualDesktopManager::self()->removeVirtualDesktop(desktops[2]);
         QCOMPARE(window->requestedTile(), rightTileD2);
         ackConfigure();
         QCOMPARE(window->tile(), rightTileD2);
@@ -883,7 +883,7 @@ void TilesTest::evacuateFromRemovedDesktop()
 
     // Remove the current desktop 2, the window is now untiles
     {
-        VirtualDesktopManager::self()->setCount(1);
+        VirtualDesktopManager::self()->removeVirtualDesktop(desktops[1]);
         QCOMPARE(window->requestedTile(), nullptr);
         ackConfigure();
         QCOMPARE(window->tile(), nullptr);
diff --git a/src/tiles/tile.cpp b/src/tiles/tile.cpp
index ec6b6f99420..680125c58c7 100644
--- a/src/tiles/tile.cpp
+++ b/src/tiles/tile.cpp
@@ -55,7 +55,10 @@ Tile::~Tile()
         if (m_quickTileMode != QuickTileFlag::Custom) {
             removeWindow(w);
         } else {
-            Tile *tile = m_tiling->bestTileForPosition(w->moveResizeGeometry().center());
+            Tile *tile = nullptr;
+            if (RootTile *root = m_tiling->rootTile(m_desktop)) {
+                tile = root->pick(w->moveResizeGeometry().center());
+            }
             removeWindow(w);
             if (tile) {
                 tile->addWindow(w);
diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index c6f1de50471..33c88b5225c 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -82,10 +82,8 @@ TileManager::TileManager(Output *parent)
     connect(VirtualDesktopManager::self(), &VirtualDesktopManager::desktopAdded, this, addDesktop);
     connect(VirtualDesktopManager::self(), &VirtualDesktopManager::desktopRemoved,
             this, [this](VirtualDesktop *desk) {
-        delete m_rootTiles[desk];
-        delete m_quickRootTiles[desk];
-        m_rootTiles.remove(desk);
-        m_quickRootTiles.remove(desk);
+        delete m_rootTiles.take(desk);
+        delete m_quickRootTiles.take(desk);
     });
     connect(VirtualDesktopManager::self(), &VirtualDesktopManager::currentChanged,
             this, [this](VirtualDesktop *oldDesk, VirtualDesktop *newDesk) {
-- 
GitLab


From c351f007a438e9c8f75e440c6a70d62013dc3389 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 20 Dec 2024 23:06:22 +0200
Subject: [PATCH 32/32] tiles: Drop TileManager::bestTileForPosition(QPointF)

It's unused.
---
 src/tiles/tilemanager.cpp | 7 +------
 src/tiles/tilemanager.h   | 1 -
 2 files changed, 1 insertion(+), 7 deletions(-)

diff --git a/src/tiles/tilemanager.cpp b/src/tiles/tilemanager.cpp
index 33c88b5225c..f7e04b27240 100644
--- a/src/tiles/tilemanager.cpp
+++ b/src/tiles/tilemanager.cpp
@@ -107,14 +107,9 @@ Output *TileManager::output() const
     return m_output;
 }
 
-Tile *TileManager::bestTileForPosition(const QPointF &pos)
-{
-    return rootTile()->pick(pos);
-}
-
 Tile *TileManager::bestTileForPosition(qreal x, qreal y)
 {
-    return bestTileForPosition({x, y});
+    return rootTile()->pick(QPointF(x, y));
 }
 
 RootTile *TileManager::rootTile(VirtualDesktop *desktop) const
diff --git a/src/tiles/tilemanager.h b/src/tiles/tilemanager.h
index c3f2d71a8ba..35c39df334a 100644
--- a/src/tiles/tilemanager.h
+++ b/src/tiles/tilemanager.h
@@ -48,7 +48,6 @@ public:
 
     Output *output() const;
 
-    KWin::Tile *bestTileForPosition(const QPointF &pos);
     Q_INVOKABLE KWin::Tile *bestTileForPosition(qreal x, qreal y); // For scripting
     RootTile *rootTile(VirtualDesktop *desktop) const;
     RootTile *rootTile() const;
-- 
GitLab

